AT_BANNER([ofproto])

AT_SETUP([ofproto - echo request])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn probe br0])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - handling messages with bad version])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor running OpenFlow 1.0, then send the switch an OF1.1 features
# request
AT_CHECK([ovs-ofctl -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/send 0205000801234567
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//
/ECHO/d' monitor.log], [0], [dnl
send: OFPT_FEATURES_REQUEST (OF1.1):
OFPT_ERROR (OF1.1): OFPBRC_BAD_VERSION
OFPT_FEATURES_REQUEST (OF1.1):
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP(["/received OpenFlow version 0x02 != expected 01/d"])
AT_CLEANUP

AT_SETUP([ofproto - feature request, config request])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPT_FEATURES_REPLY: dpid:fedcba9876543210
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY: frags=normal miss_send_len=0
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - set OpenFlow port number])
OVS_VSWITCHD_START(
       [add-port br0 p1 -- set Interface p1 type=dummy --\
        add-port br0 p2 -- set Interface p2 type=dummy ofport_request=99])
AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
AT_CHECK([[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/00:0.$/00:0x/' < stdout]],
      [0], [dnl
OFPT_FEATURES_REPLY: dpid:fedcba9876543210
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst
 1(p1): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 99(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br0): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY: frags=normal miss_send_len=0
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port stats - (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_PORT reply: 1 ports
  port LOCAL: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=0, bytes=0, drop=?, errs=?, coll=?
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port stats - (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_PORT reply (OF1.2): 1 ports
  port LOCAL: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=0, bytes=0, drop=?, errs=?, coll=?
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port stats - (OpenFlow 1.4)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/duration=[[0-9.]]*s/duration=?s/'],
  [0], [dnl
OFPST_PORT reply (OF1.4): 1 ports
  port LOCAL: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=0, bytes=0, drop=?, errs=?, coll=?
           duration=?s
           CUSTOM Statistics
                      rx_custom_packets_1=0, rx_custom_packets_2=0,
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port-desc stats (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_PORT_DESC reply:
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port-desc stats (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_PORT_DESC reply (OF1.2):
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port-desc stats (OpenFlow 1.5)])
OVS_VSWITCHD_START
add_of_ports br0 1 2 3
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/00:0./00:0x/'], [0], [dnl
OFPST_PORT_DESC reply (OF1.5):
 1(p1): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 2(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 3(p3): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br0): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-ports-desc br0 2], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/00:0./00:0x/'], [0], [dnl
OFPST_PORT_DESC reply (OF1.5):
 2(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port-desc stats (OpenFlow 1.6)])
OVS_VSWITCHD_START
add_of_ports br0 1 2 3
AT_CHECK([ovs-ofctl -F OXM-OpenFlow16 -O OpenFlow16 -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/00:0./00:0x/'], [0], [dnl
OFPST_PORT_DESC reply (OF1.6):
 1(p1): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 2(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 3(p3): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br0): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow16 -O OpenFlow16 -vwarn dump-ports-desc br0 2], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/00:0./00:0x/'], [0], [dnl
OFPST_PORT_DESC reply (OF1.6):
 2(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl CHECK_QUEUE_STATS(label, option, format)
m4_define([CHECK_QUEUE_STATS], [
AT_SETUP([ofproto - queue stats - (OpenFlow $1)])
OVS_VSWITCHD_START

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 | strip_xids], [0],
  [OFPST_QUEUE reply$3: 1 queues
  port LOCAL queue 0: bytes=?, pkts=?, errors=?, duration=?
])

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 LOCAL | strip_xids], [0],
  [OFPST_QUEUE reply$3: 1 queues
  port LOCAL queue 0: bytes=?, pkts=?, errors=?, duration=?
])

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 LOCAL 0 | strip_xids], [0],
  [OFPST_QUEUE reply$3: 1 queues
  port LOCAL queue 0: bytes=?, pkts=?, errors=?, duration=?
])

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 ANY 0 | strip_xids], [0],
  [OFPST_QUEUE reply$3: 1 queues
  port LOCAL queue 0: bytes=?, pkts=?, errors=?, duration=?
])

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 LOCAL 5 | strip_xids], [0],
  [OFPT_ERROR$3: OFPQOFC_BAD_QUEUE
OFPST_QUEUE request$3: port=LOCAL queue=5
])

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 ANY 5 | strip_xids], [0],
  [OFPT_ERROR$3: OFPQOFC_BAD_QUEUE
OFPST_QUEUE request$3: port=ANY queue=5
])

AT_CHECK([ovs-ofctl -O $2 queue-stats br0 10 | strip_xids], [0],
  [OFPT_ERROR$3: OFPQOFC_BAD_PORT
OFPST_QUEUE request$3: port=10 queue=ALL
])
OVS_VSWITCHD_STOP
AT_CLEANUP
])
CHECK_QUEUE_STATS([1.0], [OpenFlow10], [])
CHECK_QUEUE_STATS([1.1], [OpenFlow11], [ (OF1.1)])
CHECK_QUEUE_STATS([1.2], [OpenFlow12], [ (OF1.2)])
CHECK_QUEUE_STATS([1.3], [OpenFlow13], [ (OF1.3)])
CHECK_QUEUE_STATS([1.4], [OpenFlow14], [ (OF1.4)])

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - queue configuration - (OpenFlow 1.0)])
OVS_VSWITCHD_START
add_of_ports br0 1 2
AT_CHECK([ovs-ofctl queue-get-config br0 1], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY: port=1
queue 0:
])
AT_CHECK([ovs-ofctl queue-get-config br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY: port=1
OFPT_QUEUE_GET_CONFIG_REPLY: port=2
queue 0:
queue 0:
])
AT_CHECK([ovs-ofctl queue-get-config br0 10], [0],
  [OFPT_ERROR (xid=0x2): OFPQOFC_BAD_PORT
OFPT_QUEUE_GET_CONFIG_REQUEST (xid=0x2): port=10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - queue configuration - (OpenFlow 1.1)])
OVS_VSWITCHD_START
add_of_ports br0 1 2
AT_CHECK([ovs-ofctl -O OpenFlow11 queue-get-config br0 1], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY (OF1.1): port=1
queue 0:
])
AT_CHECK([ovs-ofctl -O OpenFlow11 queue-get-config br0 10 | strip_xids], [0],
  [OFPT_ERROR (OF1.1): OFPQOFC_BAD_PORT
OFPT_QUEUE_GET_CONFIG_REQUEST (OF1.1): port=10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - queue configuration - (OpenFlow 1.2)])
OVS_VSWITCHD_START
add_of_ports br0 1 2
AT_CHECK([ovs-ofctl -O OpenFlow12 queue-get-config br0 1], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY (OF1.2): port=1
queue 0:
])
AT_CHECK([ovs-ofctl -O OpenFlow12 queue-get-config br0 ANY], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY (OF1.2): port=ANY
queue 0:
queue 0:
queue 0:
])
AT_CHECK([ovs-ofctl -O OpenFlow12 queue-get-config br0 10 | strip_xids], [0],
  [OFPT_ERROR (OF1.2): OFPQOFC_BAD_PORT
OFPT_QUEUE_GET_CONFIG_REQUEST (OF1.2): port=10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - queue configuration - (OpenFlow 1.4)])
OVS_VSWITCHD_START
add_of_ports br0 1 2

AT_CHECK([ovs-ofctl -O OpenFlow14 queue-get-config br0 any | strip_xids], [0],
  [OFPST_QUEUE_DESC reply (OF1.4): port=1
queue 0:
port=2
queue 0:
port=LOCAL
queue 0:
])

AT_CHECK([ovs-ofctl -O OpenFlow14 queue-get-config br0 1 | strip_xids], [0],
  [OFPST_QUEUE_DESC reply (OF1.4): port=1
queue 0:
])

AT_CHECK([ovs-ofctl -O OpenFlow14 queue-get-config br0 10 | strip_xids], [0],
  [OFPT_ERROR (OF1.4): OFPQOFC_BAD_PORT
OFPST_QUEUE_DESC request (OF1.4): port=10
])

AT_CHECK([ovs-ofctl -O OpenFlow14 queue-get-config br0 1 2 | strip_xids], [0],
  [OFPT_ERROR (OF1.4): OFPQOFC_BAD_QUEUE
OFPST_QUEUE_DESC request (OF1.4): port=1 queue=2
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - no group support (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=actions=output:10
])
AT_DATA([stderr], [dnl
ovs-ofctl: none of the usable flow formats (OXM,OpenFlow11) is among the allowed flow formats (OpenFlow10,NXM)
])
AT_CHECK([ovs-ofctl -O OpenFlow10 -vwarn add-groups br0 groups.txt], [1], ,[stderr])
AT_CHECK([ovs-ofctl -O OpenFlow10 -vwarn mod-group br0 'group_id=1234,type=all,bucket=output:10'], [1], ,[stderr])
AT_CHECK([ovs-ofctl -O OpenFlow10 -vwarn del-groups br0], [1], ,[stderr])
AT_CHECK([ovs-ofctl -O OpenFlow10 -vwarn dump-groups br0 ], [1], ,[stderr])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - del group (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0 ], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1234,type=all,bucket=actions=output:10
 group_id=1235,type=all,bucket=actions=output:10
OFPST_GROUP_DESC reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0], [0])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
])

# Negative test.
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=0xfffffff0],
  [1], [], [ovs-ofctl: invalid group id 4294967280
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - add indirect group])
OVS_VSWITCHD_START
dnl indirect group must have exactly one bucket
AT_DATA([stderr], [dnl
OFPT_ERROR (OF1.1) (xid=0x2): OFPGMFC_INVALID_GROUP
OFPT_GROUP_MOD (OF1.1) (xid=0x2): ***decode error: OFPGMFC_INVALID_GROUP***
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 'group_id=1234,type=indirect'], [1], , [stderr])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 'group_id=1235,type=indirect,bucket=output:10'])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 'group_id=1236,type=indirect,bucket=output:10,bucket=output:11'], [1], , [stderr])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - group mod with mod and add_or_mod command])
OVS_VSWITCHD_START
dnl Check that mod-group for non-existing group fails without --may-create
AT_DATA([stderr], [dnl
OFPT_ERROR (OF1.3) (xid=0x2): OFPGMFC_UNKNOWN_GROUP
OFPT_GROUP_MOD (OF1.3) (xid=0x2):
 MOD group_id=1234,type=indirect,bucket=actions=output:2
])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn mod-group br0 'group_id=1234,type=indirect,bucket=actions=2'], [1], , [stderr])
dnl Check that mod-group for non-existing group succeeds with --may-create
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn --may-create mod-group br0 'group_id=1234,type=indirect,bucket=actions=2'])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.3):
 group_id=1234,type=indirect,bucket=actions=output:2
])
dnl Check that mod-group for existing group succeeds with --may-create
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn --may-create mod-group br0 'group_id=1234,type=indirect,bucket=actions=3'])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.3):
 group_id=1234,type=indirect,bucket=actions=output:3
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - del group (OpenFlow 1.5)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1233,type=select,selection_method=hash,bucket=output:10,bucket=output:11
group_id=1234,type=select,selection_method=hash,fields(eth_dst,ip_dst,tcp_dst),bucket=output:10,bucket=output:11
group_id=1235,type=all,bucket=actions=output:12,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
group_id=1236,type=select,selection_method=dp_hash,bucket=output:10,bucket=output:11
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=select,selection_method=hash,fields(eth_dst,ip_dst,tcp_dst),bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1233,type=select,selection_method=hash,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
 group_id=1235,type=all,bucket=bucket_id:2,actions=output:12,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
 group_id=1236,type=select,selection_method=dp_hash,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
OFPST_GROUP_DESC reply (OF1.5):
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1233,type=select,selection_method=hash,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
 group_id=1235,type=all,bucket=bucket_id:2,actions=output:12,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
 group_id=1236,type=select,selection_method=dp_hash,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
OFPST_GROUP_DESC reply (OF1.5):
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn del-groups br0], [0])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - del group deletes flows])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-groups br0 groups.txt])
AT_DATA([flows.txt], [dnl
tcp actions=group:1234
table=2 udp actions=group:1235
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 table=2, udp actions=group:1235
 tcp actions=group:1234
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 table=2, udp actions=group:1235
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 table=2, udp actions=group:1235
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - insert group buckets])
OVS_VSWITCHD_START
# Add group with no buckets.
AT_DATA([groups.txt], [dnl
group_id=1234,type=all
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all
])

# Add two buckets, using "last".
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=last,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])

# Start over again, then add two buckets using "first".
AT_CHECK([ovs-ofctl -O OpenFlow15 --strict del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-group br0 group_id=1234,type=all])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=first,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])

# Add two more buckets before the existing ones.
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=first,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])

# Add another bucket at the end.
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=last,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])

# Verify that duplicate bucket IDs are rejected.
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=last,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/truncated/,$d'], [0], [dnl
OFPT_ERROR (OF1.5): OFPGMFC_BUCKET_EXISTS
OFPT_GROUP_MOD (OF1.5):
 INSERT_BUCKET command_bucket_id:last,group_id=1234,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])


# Add another bucket just before bucket 15.
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=15])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])

# Add two more buckets just before bucket 11,
# getting the command from a file.
AT_DATA([buckets.txt], [dnl
group_id=1234,command_bucket_id=11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 - < buckets.txt])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])

# Add yet two more buckets.
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=15,bucket=bucket_id:20,actions=output:20,bucket=bucket_id:21,actions=output:21])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:20,actions=output:20,bucket=bucket_id:21,actions=output:21
])

# Delete groups.
AT_CHECK([ovs-ofctl -O OpenFlow15 del-groups br0])

# Add "fast_failover" group, then insert a bucket into it and make
# sure that the type of the group doesn't change.  (There was a bug
# that caused this to happen.)
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-group br0 group_id=1234,type=ff])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=ff
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=first,bucket=bucket_id:20,actions=output:20,bucket=bucket_id:21,actions=output:21])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=ff,bucket=bucket_id:20,actions=output:20,bucket=bucket_id:21,actions=output:21
])

# Negative tests.
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=123,type=indirect,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1], [1], [],
  [ovs-ofctl: type is not needed
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=123,selection_method=dp_hash,type=indirect,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1], [1], [],
  [ovs-ofctl: selection method is not needed
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=0xffffff01,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1], [1], [],
  [ovs-ofctl: invalid command bucket id 4294967041
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=first,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1], [1], [],
  [ovs-ofctl: insert-bucket needs OpenFlow 1.5 or later ('-O OpenFlow15')
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - remove group buckets])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:16,actions=output:16
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:16,actions=output:16
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=first])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:16,actions=output:16
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=last])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=13])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])
AT_DATA([buckets.txt], [dnl
group_id=1234
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 - < buckets.txt])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=first])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=last])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=all])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=1], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0], [dnl
OFPT_ERROR (OF1.5): OFPGMFC_UNKNOWN_BUCKET
OFPT_GROUP_MOD (OF1.5):
 REMOVE_BUCKET command_bucket_id:1,group_id=1234
])
# Negative test.
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=last], [1], [],
  [ovs-ofctl: remove-bucket needs OpenFlow 1.5 or later ('-O OpenFlow15')
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle del group (OpenFlow 1.3)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow13 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-groups br0 ], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1234,type=all,bucket=actions=output:10
 group_id=1235,type=all,bucket=actions=output:10
OFPST_GROUP_DESC reply (OF1.3):
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow13 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.3):
 group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow13 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.3):
 group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow13 -vwarn del-groups br0], [0])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.3):
])

# Negative test.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow13 -vwarn del-groups br0 group_id=0xfffffff0],
  [1], [], [ovs-ofctl: invalid group id 4294967280
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle add indirect group])
OVS_VSWITCHD_START
dnl indirect group must have exactly one bucket
AT_DATA([stderr], [dnl
OFPT_ERROR (OF1.4) (xid=0x2): OFPGMFC_INVALID_GROUP
OFPT_BUNDLE_ADD_MESSAGE (OF1.4) (xid=0x2):
 bundle_id=0 flags=atomic ordered
OFPT_GROUP_MOD (OF1.4) (xid=0x2): ***decode error: OFPGMFC_INVALID_GROUP***
])
AT_CHECK([ovs-ofctl --bundle -vwarn add-group br0 'group_id=1234,type=indirect'], [1], , [stderr])
AT_CHECK([ovs-ofctl --bundle -vwarn add-group br0 'group_id=1235,type=indirect,bucket=output:10'])
AT_CHECK([ovs-ofctl --bundle -vwarn add-group br0 'group_id=1236,type=indirect,bucket=output:10,bucket=output:11'], [1], , [stderr])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle group mod with mod and add_or_mod command])
OVS_VSWITCHD_START
dnl Check that mod-group for non-existing group fails without --may-create
AT_DATA([stderr], [dnl
OFPT_ERROR (OF1.4) (xid=0x2): OFPGMFC_UNKNOWN_GROUP
OFPT_GROUP_MOD (OF1.4) (xid=0x2):
 MOD group_id=1234,type=indirect,bucket=actions=output:2
])
AT_CHECK([ovs-ofctl --bundle -vwarn mod-group br0 'group_id=1234,type=indirect,bucket=actions=2'], [1], , [stderr])
dnl Check that mod-group for non-existing group succeeds with --may-create
AT_CHECK([ovs-ofctl --bundle -vwarn --may-create mod-group br0 'group_id=1234,type=indirect,bucket=actions=2'])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.4):
 group_id=1234,type=indirect,bucket=actions=output:2
])
dnl Check that mod-group for existing group succeeds with --may-create
AT_CHECK([ovs-ofctl --bundle -vwarn --may-create mod-group br0 'group_id=1234,type=indirect,bucket=actions=3'])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.4):
 group_id=1234,type=indirect,bucket=actions=output:3
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle del group (OpenFlow 1.5)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1233,type=select,selection_method=hash,bucket=output:10,bucket=output:11
group_id=1234,type=select,selection_method=hash,fields(eth_dst,ip_dst,tcp_dst),bucket=output:10,bucket=output:11
group_id=1235,type=all,bucket=actions=output:12,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=select,selection_method=hash,fields(eth_dst,ip_dst,tcp_dst),bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1233,type=select,selection_method=hash,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
 group_id=1235,type=all,bucket=bucket_id:2,actions=output:12,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
OFPST_GROUP_DESC reply (OF1.5):
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1233,type=select,selection_method=hash,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
 group_id=1235,type=all,bucket=bucket_id:2,actions=output:12,bucket=bucket_id:0,actions=output:10,bucket=bucket_id:1,actions=output:11
OFPST_GROUP_DESC reply (OF1.5):
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn del-groups br0], [0])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle del group deletes flows])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl --bundle -vwarn add-groups br0 groups.txt])
AT_DATA([flows.txt], [dnl
tcp actions=group:1234
table=2 udp actions=group:1235
])
AT_CHECK([ovs-ofctl --bundle -vwarn add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 table=2, udp actions=group:1235
 tcp actions=group:1234
OFPST_FLOW reply (OF1.4):
])
AT_CHECK([ovs-ofctl --bundle -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 table=2, udp actions=group:1235
OFPST_FLOW reply (OF1.4):
])
AT_CHECK([ovs-ofctl --bundle -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 table=2, udp actions=group:1235
OFPST_FLOW reply (OF1.4):
])
AT_CHECK([ovs-ofctl --bundle -vwarn del-groups br0])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
OFPST_FLOW reply (OF1.4):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
dnl Actions definition listed in both supported formats (w/ actions=)
AT_SETUP([ofproto - bundle insert group buckets])
OVS_VSWITCHD_START
# Add group with no buckets.
AT_DATA([groups.txt], [dnl
group_id=1234,type=all
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all
])

# Add two buckets, using "last".
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=last,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])

# Start over again, then add two buckets using "first".
AT_DATA([groups.txt], [dnl
delete group_id=1234
add group_id=1234,type=all
insert_bucket group_id=1234,command_bucket_id=first,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])

# Add two more buckets before the existing ones.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=first,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11
])

# Add another bucket at the end.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=last,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])

# Verify that duplicate bucket IDs are rejected.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=last,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/talking to/,$d'], [0], [dnl
Error OFPGMFC_BUCKET_EXISTS for: OFPT_GROUP_MOD (OF1.5):
 INSERT_BUCKET command_bucket_id:last,group_id=1234,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
Error OFPBFC_MSG_FAILED for: OFPT_BUNDLE_CONTROL (OF1.5):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
])

# Add another bucket just before bucket 15.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=15])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])

# Add two more buckets just before bucket 11,
# getting the command from a file.
AT_DATA([buckets.txt], [dnl
group_id=1234,command_bucket_id=11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 - < buckets.txt])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])

# Add yet two more buckets.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=15,bucket=bucket_id:20,actions=output:20,bucket=bucket_id:21,actions=output:21])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:20,actions=output:20,bucket=bucket_id:21,actions=output:21
])

# Negative tests.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn insert-buckets br0 group_id=1234,command_bucket_id=0xffffff01,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1], [1], [],
  [ovs-ofctl: invalid command bucket id 4294967041
])
AT_CHECK([ovs-ofctl --bundle -vwarn insert-buckets br0 group_id=1234,command_bucket_id=first,bucket=bucket_id:0,actions=output:0,bucket=bucket_id:1,actions=output:1], [1], [],
  [ovs-ofctl: insert-bucket needs OpenFlow 1.5 or later ('-O OpenFlow15')
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle remove group buckets])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:16,actions=output:16
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:10,actions=output:10,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:16,actions=output:16
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=first])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15,bucket=bucket_id:16,actions=output:16
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=last])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:13,actions=output:13,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=13])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=bucket_id:11,actions=output:11,bucket=bucket_id:12,actions=output:12,bucket=bucket_id:14,actions=output:14,bucket=bucket_id:15,actions=output:15
])
AT_DATA([buckets.txt], [dnl
group_id=1234
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 - < buckets.txt])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all
])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=first])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=last])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=all])
AT_CHECK([ovs-ofctl --bundle -O OpenFlow15 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=1], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr | sed '/talking to/,$d'], [0], [dnl
Error OFPGMFC_UNKNOWN_BUCKET for: OFPT_GROUP_MOD (OF1.5):
 REMOVE_BUCKET command_bucket_id:1,group_id=1234
Error OFPBFC_MSG_FAILED for: OFPT_BUNDLE_CONTROL (OF1.5):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
])
# Negative test.
AT_CHECK([ovs-ofctl --bundle -O OpenFlow11 -vwarn remove-buckets br0 group_id=1234,command_bucket_id=last], [1], [],
  [ovs-ofctl: remove-bucket needs OpenFlow 1.5 or later ('-O OpenFlow15')
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - flow mod checks group availability])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 group_id=1234,type=all,bucket=output:10])
AT_DATA([flows.txt], [dnl
tcp actions=group:1234
udp actions=group:1235
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flow br0 'tcp actions=group:1234'])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flow br0 'tcp actions=group:1235'], [1], [], [stderr])

AT_CHECK([strip_xids < stderr], [0],
  [OFPT_ERROR (OF1.1): OFPBAC_BAD_OUT_GROUP
OFPT_FLOW_MOD (OF1.1): ADD tcp actions=group:1235
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle flow mod checks group availability])
OVS_VSWITCHD_START
AT_DATA([bundle.txt], [dnl
group add group_id=1234,type=all,bucket=output:10
flow add tcp actions=group:1234
flow add udp actions=group:1235
])
AT_CHECK([ovs-ofctl -vwarn bundle br0 bundle.txt], [1], [], [stderr])

AT_CHECK([ofctl_strip < stderr | sed '/talking to/,$d'], [0],
  [dnl
Error OFPBAC_BAD_OUT_GROUP for: OFPT_FLOW_MOD (OF1.4): ADD udp actions=group:1235
Error OFPBFC_MSG_FAILED for: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group description])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 group_id=1234,type=all,bucket=output:10], [0], [stdout])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1234,type=all,bucket=actions=output:10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group description])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 group_id=1234,type=all,bucket=output:10])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1234,type=all,bucket=actions=output:10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group features])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn dump-group-features br0], [0], [stdout])
AT_CHECK([strip_xids < stdout], [0], [dnl
OFPST_GROUP_FEATURES reply (OF1.2):
 Group table:
    Types:  0xf
    Capabilities:  0x7
    all group:
       max_groups=0xffffff00
       actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
    select group:
       max_groups=0xffffff00
       actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
    indirect group:
       max_groups=0xffffff00
       actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
    fast failover group:
       max_groups=0xffffff00
       actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group stats (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flow br0 'tcp actions=group:1234'])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-group-stats br0 group_id=1234], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1234,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-group-stats br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sort], [0], [dnl
 group_id=1234,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
 group_id=1235,ref_count=0,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group stats (OpenFlow 1.3)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn add-flow br0 'tcp actions=group:1234'])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-group-stats br0 group_id=1234], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/duration=[[0-9.]]*s/duration=?s/' | sort], [0], [dnl
 group_id=1234,duration=?s,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.3):
])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn dump-group-stats br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/duration=[[0-9.]]*s/duration=?s/' | sort], [0], [dnl
 group_id=1234,duration=?s,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
 group_id=1235,duration=?s,ref_count=0,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.3):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group stats (OpenFlow 1.5)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn add-flow br0 'tcp actions=group:1234'])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-group-stats br0 group_id=1234], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/duration=[[0-9.]]*s/duration=?s/' | sort], [0], [dnl
 group_id=1234,duration=?s,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.5):
])
AT_CHECK([ovs-ofctl -O OpenFlow15 -vwarn dump-group-stats br0], [0], [stdout])
AT_CHECK([strip_xids < stdout | sed 's/duration=[[0-9.]]*s/duration=?s/' | sort], [0], [dnl
 group_id=1234,duration=?s,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
 group_id=1235,duration=?s,ref_count=0,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.5):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This found a use-after-free error in bridge destruction in the
dnl presence of groups.
AT_SETUP([ofproto - group add then bridge delete (OpenFlow 1.3)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10

dnl This checks for regression against a parser bug such that
dnl "actions=resbmit(,1)" etc. was rejected as a syntax error.
group_id=2345,type=select,bucket=weight:10,actions=resubmit(,1),bucket=weight:10,actions=resubmit(,2),bucket=weight:1,actions=resubmit(,3)
])
AT_CHECK([ovs-ofctl -O OpenFlow13 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-vsctl del-br br0])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.0)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 0' \
    'noflood NO_FLOOD 0' \
    'down PORT_DOWN,NO_FLOOD LINK_DOWN' \
    'flood PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV 0' \
    'receive 0 0'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([strip_xids < stdout], [0], [dnl
OFPT_FEATURES_REPLY: dpid:fedcba9876543210
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY: frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.2)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 LIVE' \
    'down PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV LIVE' \
    'receive 0 LIVE'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([strip_xids < stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.2): dpid:fedcba9876543210
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS QUEUE_STATS
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.2): frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.4)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 LIVE' \
    'down PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV LIVE' \
    'receive 0 LIVE'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([strip_xids < stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.4): dpid:fedcba9876543210
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS QUEUE_STATS BUNDLES
OFPST_PORT_DESC reply (OF1.4):
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.4): frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.6)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 LIVE' \
    'down PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV LIVE' \
    'receive 0 LIVE'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -O OpenFlow16 -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -O OpenFlow16 -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([strip_xids < stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.6): dpid:fedcba9876543210
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS QUEUE_STATS BUNDLES
OFPST_PORT_DESC reply (OF1.6):
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.6): frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl add-flows br0 -])
AT_CHECK([ovs-ofctl add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -F nxm add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl dump-aggregate br0 table=0 | strip_xids], [0], [dnl
NXST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply:
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl -F openflow10 add-flows br0 -])
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
OFPST_FLOW reply:
])
AT_CHECK([ovs-ofctl -F openflow10 dump-aggregate br0 table=0 | strip_xids], [0], [dnl
OFPST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl -F openflow10 del-flows br0])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

# It's really dumb that check_overlap and reset_counts are considered
# part of flow state, but OpenFlow implies that it is, and OFTest and
# some users insist on it.
AT_SETUP([ofproto - add-flow and flags])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 check_overlap,in_port=1,actions=drop])
# Prior to OF1.3, flow dumps didn't include a "flags" field.
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply:
 in_port=1 actions=drop
])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.1):
 in_port=1 actions=drop
])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.2):
 in_port=1 actions=drop
])
# OF1.3 makes the flags visible.
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.3):
 check_overlap reset_counts in_port=1 actions=drop
])
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.4):
 check_overlap reset_counts in_port=1 actions=drop
])
AT_CHECK([ovs-ofctl -O OpenFlow15 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.5):
 check_overlap reset_counts in_port=1 actions=drop
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.1):
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl -O OpenFlow11 add-flows br0 -])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-aggregate br0 table=0 | strip_xids], [0], [dnl
OFPST_AGGREGATE reply (OF1.1): packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.1):
 table=1, in_port=4 actions=output:3
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow_mod negative test (OpenFlow 1.1)])
OVS_VSWITCHD_START(
  [set bridge br0 protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13])
AT_CHECK([ovs-ofctl add-flow -O OpenFlow11 br0 table=1,action=goto_table:2])

# The error message here actually comes from ovs-ofctl, not from ovs-vswitchd,
# but at least it's the same code in ofpacts_check() that issues the error.
AT_CHECK([ovs-ofctl add-flow -O OpenFlow11 br0 table=1,action=goto_table:1],
  [1], [],
  [ovs-ofctl: actions are invalid with specified match (OFPBIC_BAD_TABLE_ID)
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - set-field flow_mod commands (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 ipv6,table=1,in_port=3,actions=drop])
AT_CHECK([ovs-ofctl add-flow br0 ipv6,table=1,in_port=3,actions=set_field:fe80:0123:4567:890a:a6ba:dbff:fefe:59fa-\>ipv6_src])
AT_CHECK([ovs-ofctl add-flow br0 icmp6,icmp_type=136,table=1,in_port=3,actions=set_field:fe80:8675:3097:890a:a6ba:dbff:f00d:59fa-\>nd_target,set_field:cc:dd:ee:ff:00:11-\>nd_tll])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 table=1, icmp6,in_port=3,icmp_type=136 actions=load:0xa6badbfff00d59fa->NXM_NX_ND_TARGET[[0..63]],load:0xfe8086753097890a->NXM_NX_ND_TARGET[[64..127]],load:0xccddeeff0011->NXM_NX_ND_TLL[[]]
 table=1, ipv6,in_port=3 actions=load:0xa6badbfffefe59fa->NXM_NX_IPV6_SRC[[0..63]],load:0xfe8001234567890a->NXM_NX_IPV6_SRC[[64..127]]
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.2):
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl -O OpenFlow12 add-flows br0 -])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - set-field flow_mod commands (OF1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 ipv6,table=1,in_port=3,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 ipv6,table=1,in_port=3,actions=set_field:fe80:0123:4567:890a:a6ba:dbff:fefe:59fa-\>ipv6_src])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 icmp6,icmp_type=136,table=1,in_port=3,actions=set_field:fe80:8675:3097:890a:a6ba:dbff:f00d:59fa-\>nd_target,set_field:cc:dd:ee:ff:00:11-\>nd_tll])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 table=1, icmp6,in_port=3,icmp_type=136 actions=set_field:fe80:8675:3097:890a:a6ba:dbff:f00d:59fa->nd_target,set_field:cc:dd:ee:ff:00:11->nd_tll
 table=1, ipv6,in_port=3 actions=set_field:fe80:123:4567:890a:a6ba:dbff:fefe:59fa->ipv6_src
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - dump flows with cookie])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl dump-aggregate br0 table=0 | strip_xids], [0], [dnl
NXST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=3
])
AT_CHECK([ovs-ofctl dump-flows br0 cookie=0x3/-1 | ofctl_strip | sort], [0], [dnl
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl dump-aggregate br0 cookie=0x3/-1 | strip_xids], [0], [dnl
NXST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=1
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie change (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F openflow10 mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=1 actions=output:1
OFPST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie change (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F nxm add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=1 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - no mod flow with cookie change (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl The OpenFlow 1.2 spec states that the cookie may not be modified
AT_SETUP([ofproto - no mod flow with cookie change (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.2):
])

AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flows based on cookie mask (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=0x1/0xff,actions=4])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:4
 cookie=0x1, in_port=2 actions=output:4
 cookie=0x2, in_port=3 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flows based on cookie mask (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.1):
])

AT_CHECK([ovs-ofctl -O OpenFlow11 mod-flows br0 cookie=0x1/0xff,actions=4])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:4
 cookie=0x1, in_port=2 actions=output:4
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flows based on cookie mask (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.2):
])

AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 cookie=0x1/0xff,actions=4])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:4
 cookie=0x1, in_port=2 actions=output:4
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl The OpenFlow 1.2 spec states that the cookie may not be modified
AT_SETUP([ofproto - mod flows based on cookie mask with cookie change])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=1/-1,cookie=4,actions=4])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=3 actions=output:1
 cookie=0x4, in_port=1 actions=output:4
 cookie=0x4, in_port=2 actions=output:4
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask==0) - NXM])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F nxm mod-flows br0 in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask==0) - OF1.1])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow11 mod-flows br0 in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:1
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask==0) - OF1.2])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow12 mod-flows br0 in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask!=0) - NXM])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=1/1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask!=0) - OF1.1])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow11 mod-flows br0 cookie=1/1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask!=0) - OF1.2])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow12 mod-flows br0 cookie=1/1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows with cookies])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on cookie])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl del-flows br0 cookie=0x3/-1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on cookie mask])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0 cookie=0x3/0x1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=2 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on table id (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0 table=0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, table=1, in_port=2 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0 table=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on table id (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 table=0])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 table=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.1):
 cookie=0x2, table=1, in_port=2 actions=output:1
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on table id (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0 table=0])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0 table=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow_mod with out_port matching (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_DATA([flows.txt], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1,output:2,output:3
 in_port=3 actions=output:3,output:1,output:2
 in_port=4 actions=drop
 in_port=5 actions=output:3
 in_port=6 actions=output:1
])
AT_CHECK([ovs-ofctl -F openflow10 add-flows br0 flows.txt])
(cat flows.txt; echo 'OFPST_FLOW reply:') > expout
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

(grep 'output:2' flows.txt; echo 'OFPST_FLOW reply:') > expout
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 out_port=2 | ofctl_strip | sort], [0], [expout])

AT_CHECK([ovs-ofctl -F openflow10 del-flows br0 out_port=2])
(grep -v 'output:2' flows.txt; echo 'OFPST_FLOW reply:') > expout
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -F openflow10 del-flows br0 out_port=3])
(grep -v 'output:[[23]]' flows.txt; echo 'OFPST_FLOW reply:') > expout
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -F openflow10 del-flows br0 out_port=1])
(grep -v 'output:[[123]]' flows.txt; echo 'OFPST_FLOW reply:') > expout
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow_mod with out_port matching (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_DATA([flows.txt], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1,write_actions(output:2,output:3)
 in_port=3 actions=output:3,output:1,write_actions(output:2)
 in_port=4 actions=drop
 in_port=5 actions=write_actions(output:3)
 in_port=6 actions=output:1
])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flows br0 flows.txt])
(cat flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

(grep 'output:2' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 out_port=2 | ofctl_strip | sort], [0], [expout])

AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 out_port=2])
(grep -v 'output:2' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 out_port=3])
(grep -v 'output:[[23]]' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 out_port=1])
(grep -v 'output:[[123]]' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow_mod with out_group matching (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1,type=all,bucket=output:10
group_id=2,type=all,bucket=output:10
group_id=3,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-groups br0 groups.txt])
AT_DATA([flows.txt], [dnl
 in_port=1 actions=group:2,output:5
 in_port=2 actions=group:1,write_actions(group:2,group:3,output:6)
 in_port=3 actions=group:3,group:1,write_actions(group:2,output:3)
 in_port=4 actions=output:4
 in_port=5 actions=write_actions(output:4,group:3)
 in_port=6 actions=group:1
])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flows br0 flows.txt])
(cat flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

(grep 'output:3' flows.txt | grep 'group:2'; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 out_port=3,out_group=2 | ofctl_strip | sort], [0], [expout])

AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 out_group=2])
(grep -v 'group:2' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 out_group=3])
(grep -v 'group:[[23]]' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 out_group=1])
(grep -v 'group:[[123]]' flows.txt; echo 'OFPST_FLOW reply (OF1.1):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle flow_mod with out group matching (OpenFlow 1.4)])
OVS_VSWITCHD_START
AT_DATA([bundle.txt], [dnl
group group_id=1,type=all,bucket=output:10
group group_id=2,type=all,bucket=output:10
group group_id=3,type=all,bucket=output:10
flow in_port=1 actions=group:2,output:5
flow in_port=2 actions=group:1,write_actions(group:2,group:3,output:6)
flow in_port=3 actions=group:3,group:1,write_actions(group:2,output:3)
flow in_port=4 actions=output:4
flow in_port=5 actions=write_actions(output:4,group:3)
flow in_port=6 actions=group:1
])
AT_CHECK([ovs-ofctl bundle br0 bundle.txt])

# for checking
AT_DATA([flows.txt], [dnl
 in_port=1 actions=group:2,output:5
 in_port=2 actions=group:1,write_actions(group:2,group:3,output:6)
 in_port=3 actions=group:3,group:1,write_actions(group:2,output:3)
 in_port=4 actions=output:4
 in_port=5 actions=write_actions(output:4,group:3)
 in_port=6 actions=group:1
])

(cat flows.txt; echo 'OFPST_FLOW reply (OF1.4):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

(grep 'output:3' flows.txt | grep 'group:2'; echo 'OFPST_FLOW reply (OF1.4):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 out_port=3,out_group=2 | ofctl_strip | sort], [0], [expout])

AT_CHECK([ovs-ofctl -O OpenFlow14 del-flows br0 out_group=2])
(grep -v 'group:2' flows.txt; echo 'OFPST_FLOW reply (OF1.4):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -O OpenFlow14 del-flows br0 out_group=3])
(grep -v 'group:[[23]]' flows.txt; echo 'OFPST_FLOW reply (OF1.4):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

AT_CHECK([ovs-ofctl -O OpenFlow14 del-flows br0 out_group=1])
(grep -v 'group:[[123]]' flows.txt; echo 'OFPST_FLOW reply (OF1.4):') > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [expout])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle packet-out (OpenFlow 1.4)])
OVS_VSWITCHD_START

ovs-ofctl del-flows br0
ovs-ofctl add-flow br0 priority=0,actions=drop

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# This bundle adds a group, a flow using that group and then a
# packet-out that needs them both.  Finally the bundle deletes all
# groups, which also deletes the flow, leaving only the drop flow in
# the table.  If this works properly, the packet-out should get
# translated and processed before the flow disappears.  Also, if the
# bundle were to fail, the packet-in should not get executed.
AT_DATA([bundle.txt], [dnl
group group_id=1,type=all,bucket=output:controller
flow in_port=6 actions=group:1
packet-out in_port=6, packet=0001020304050010203040501234 actions=table
group delete
])
AT_CHECK([ovs-ofctl bundle br0 bundle.txt])

# Verify that only the drop flow remains.
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [ reset_counts priority=0 actions=drop
OFPST_FLOW reply (OF1.4):
])

# Verify that the packet-in was received via controller action.
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
  [OFPT_PACKET_IN (xid=0x0): total_len=14 in_port=6 (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle packet-out, failing bundle commit (OpenFlow 1.4)])
OVS_VSWITCHD_START

ovs-ofctl del-flows br0
ovs-ofctl add-flow br0 priority=0,actions=drop

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# This bundle adds a flow using that group and then a packet-out that
# needs them both.  Finally the bundle adds another flow that referes
# to a non-existing group, causing the bundle to fail, and the
# packet-in should not get executed.
AT_DATA([bundle.txt], [dnl
group group_id=1,type=all,bucket=output:controller
flow in_port=6 actions=group:1
packet-out in_port=6, packet=0001020304050010203040501234 actions=table
flow in_port=7 actions=group:2
])
AT_CHECK([ovs-ofctl bundle br0 bundle.txt 2>&1 | sed '/talking to/,$d' | strip_xids], [], [dnl
Error OFPBAC_BAD_OUT_GROUP for: OFPT_FLOW_MOD (OF1.4): ADD in_port=7 actions=group:2
Error OFPBFC_MSG_FAILED for: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
])

# Verify that only the drop flow remains.
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [ reset_counts priority=0 actions=drop
OFPST_FLOW reply (OF1.4):
])

# Verify that the packet-in was NOT received via controller action.
AT_CHECK([strip_xids < monitor.log], [0], [])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle packet-out makes bundle commit to fail(OpenFlow 1.4)])
OVS_VSWITCHD_START

ovs-ofctl del-flows br0
ovs-ofctl add-flow br0 priority=0,actions=drop

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# This bundle adds a flow using that group and then a packet-out that
# needs them both.  Finally the bundle adds another flow that referes
# to a non-existing group, causing the bundle to fail, and the
# packet-in should not get executed.
AT_DATA([bundle.txt], [dnl
group group_id=1,type=all,bucket=output:controller
flow in_port=6 actions=group:1
packet-out in_port=6, packet=0001020304050010203040501234 actions=table
packet-out in_port=6, packet=0001020304050010203040501234 actions=group:2
])
AT_CHECK([ovs-ofctl bundle br0 bundle.txt 2>&1 | sed '/talking to/,$d' | strip_xids], [], [dnl
Error OFPBAC_BAD_OUT_GROUP for: OFPT_PACKET_OUT (OF1.4): in_port=6 actions=group:2 data_len=14
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
Error OFPBFC_MSG_FAILED for: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
])

# Verify that only the drop flow remains.
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-flows br0 | ofctl_strip | sort], [0],
  [ reset_counts priority=0 actions=drop
OFPST_FLOW reply (OF1.4):
])

# Verify that the packet-in was NOT received via controller action.
AT_CHECK([strip_xids < monitor.log], [0], [])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow table configuration (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Check the default configuration.
head_table() {
    printf 'OFPST_TABLE reply (xid=0x2):
  table 0%s:
    active=0, lookup=0, matched=0
    max_entries=1000000
    matching:
      in_port: exact match or wildcard
      eth_src: exact match or wildcard
      eth_dst: exact match or wildcard
      eth_type: exact match or wildcard
      vlan_vid: exact match or wildcard
      vlan_pcp: exact match or wildcard
      ip_src: exact match or wildcard
      ip_dst: exact match or wildcard
      nw_proto: exact match or wildcard
      nw_tos: exact match or wildcard
      tcp_src: exact match or wildcard
      tcp_dst: exact match or wildcard

' "$1"
}
ditto() {
    for i in `seq $1 $2`; do
        printf '  table %d: ditto\n' $i
    done
}
(head_table; ditto 1 253) > expout
AT_CHECK([ovs-ofctl dump-tables br0], [0], [expout])
# Change the configuration.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=main \
     -- --id=@t1 create Flow_Table flow-limit=1024 \
     -- set bridge br0 'flow_tables={1=@t1,0=@t0}' \
   | uuidfilt],
  [0], [<0>
<1>
])
# Check that the configuration was updated.
(head_table ' ("main")'; echo '  table 1:
    active=0, lookup=0, matched=0
    max_entries=1024
    (same matching)

  table 2:
    active=0, lookup=0, matched=0
    max_entries=1000000
    (same matching)
'; ditto 3 253) > expout
AT_CHECK([ovs-ofctl dump-tables br0], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl In-band and fail-open add "hidden rules" to table 0.  These rules shouldn't
dnl be visible to OpenFlow.  This test checks that "dump-flows" and
dnl "dump-tables" don't make them visible.
AT_SETUP([ofproto - hidden rules not in table stats])
# Use an IP address for a controller that won't actually exist: we
# want to create in-band rules but we do not want to actually connect
# to a controller (because that could mess about with our test).  The
# Class E range 240.0.0.0 - 255.255.255.255 seems like a good choice.
OVS_VSWITCHD_START([set-controller br0 tcp:240.0.0.1:6653])
for i in 1 2 3 4 5; do ovs-appctl time/warp 1000; done

# Check that no hidden flows are visible in OpenFlow.
AT_CHECK([ovs-ofctl dump-flows br0 | strip_xids], [0], [NXST_FLOW reply:
])

# Check that some hidden flows related to 240.0.0.1 are actually in table 0.
#
# We discard flows that mention table_id because we only want table 0 flows,
# which in OVS is implied by the absence of a table_id.
AT_CHECK([ovs-appctl bridge/dump-flows br0], [0], [stdout])
AT_CHECK([test `grep '240\.0\.0\.1' stdout | grep -v table_id= | wc -l` -gt 0])

# Check that dump-tables doesn't count the hidden flows.
head_table() {
    printf 'OFPST_TABLE reply:
  table 0:
    active=0, lookup=0, matched=0
    max_entries=1000000
    matching:
      in_port: exact match or wildcard
      eth_src: exact match or wildcard
      eth_dst: exact match or wildcard
      eth_type: exact match or wildcard
      vlan_vid: exact match or wildcard
      vlan_pcp: exact match or wildcard
      ip_src: exact match or wildcard
      ip_dst: exact match or wildcard
      nw_proto: exact match or wildcard
      nw_tos: exact match or wildcard
      tcp_src: exact match or wildcard
      tcp_dst: exact match or wildcard

'
}
ditto() {
    for i in `seq $1 $2`; do
        printf '  table %d: ditto\n' $i
    done
}
(head_table; ditto 1 253) > expout
AT_CHECK([ovs-ofctl dump-tables br0 | strip_xids], [0], [expout])
OVS_VSWITCHD_STOP(["/240\.0\.0\.1/d"])
AT_CLEANUP

AT_SETUP([ofproto - flow table configuration (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Check the default configuration.
head_table() {
    printf 'OFPST_TABLE reply (OF1.2) (xid=0x2):
  table 0%s:
    active=0, lookup=0, matched=0
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    config=controller
    max_entries=1000000
    instructions (table miss and others):
      instructions: apply_actions,clear_actions,write_actions,write_metadata,goto_table
      Write-Actions and Apply-Actions features:
        actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
        supported on Set-Field: metadata in_port_oxm eth_src eth_dst vlan_vid vlan_pcp mpls_label mpls_tc ip_src ip_dst ipv6_src ipv6_dst ipv6_label ip_dscp nw_ecn arp_op arp_spa arp_tpa arp_sha arp_tha tcp_src tcp_dst udp_src udp_dst sctp_src sctp_dst icmp_type icmp_code icmpv6_type icmpv6_code nd_target nd_sll nd_tll
    matching:
      metadata: exact match or wildcard
      in_port_oxm: exact match or wildcard
      eth_src: exact match or wildcard
      eth_dst: exact match or wildcard
      eth_type: exact match or wildcard
      vlan_vid: exact match or wildcard
      vlan_pcp: exact match or wildcard
      mpls_label: exact match or wildcard
      mpls_tc: exact match or wildcard
      ip_src: exact match or wildcard
      ip_dst: exact match or wildcard
      ipv6_src: exact match or wildcard
      ipv6_dst: exact match or wildcard
      ipv6_label: exact match or wildcard
      nw_proto: exact match or wildcard
      ip_dscp: exact match or wildcard
      nw_ecn: exact match or wildcard
      arp_op: exact match or wildcard
      arp_spa: exact match or wildcard
      arp_tpa: exact match or wildcard
      arp_sha: exact match or wildcard
      arp_tha: exact match or wildcard
      tcp_src: exact match or wildcard
      tcp_dst: exact match or wildcard
      udp_src: exact match or wildcard
      udp_dst: exact match or wildcard
      sctp_src: exact match or wildcard
      sctp_dst: exact match or wildcard
      icmp_type: exact match or wildcard
      icmp_code: exact match or wildcard
      icmpv6_type: exact match or wildcard
      icmpv6_code: exact match or wildcard
      nd_target: exact match or wildcard
      nd_sll: exact match or wildcard
      nd_tll: exact match or wildcard

' "$1"
}
ditto() {
    for i in `seq $1 $2`; do
        printf '  table %d: ditto\n' $i
    done
}
tail_table() {
    printf '  table 253:
    active=0, lookup=0, matched=0
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    config=controller
    max_entries=1000000
    instructions (table miss and others):
      instructions: apply_actions,clear_actions,write_actions,write_metadata
      (same actions)
    (same matching)
'
}
(head_table; ditto 1 252; tail_table) > expout
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-tables br0], [0], [expout])
# Change the configuration.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=main \
     -- --id=@t1 create Flow_Table flow-limit=1024 \
     -- set bridge br0 'flow_tables={1=@t1,0=@t0}' \
   | uuidfilt],
  [0], [<0>
<1>
])
# Check that the configuration was updated.
(head_table ' ("main")'; echo '  table 1:
    active=0, lookup=0, matched=0
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    config=controller
    max_entries=1024
    (same instructions)
    (same matching)

  table 2:
    active=0, lookup=0, matched=0
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    config=controller
    max_entries=1000000
    (same instructions)
    (same matching)
'; ditto 3 252; tail_table) > expout
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-tables br0], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - table features (OpenFlow 1.3)])
OVS_VSWITCHD_START
head_table () {
    printf '  table 0%s:
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    max_entries=1000000
    instructions (table miss and others):
      next tables: 1-253
      instructions: meter,apply_actions,clear_actions,write_actions,write_metadata,goto_table
      Write-Actions and Apply-Actions features:
        actions: output group set_field strip_vlan push_vlan mod_nw_ttl dec_ttl set_mpls_ttl dec_mpls_ttl push_mpls pop_mpls set_queue
        supported on Set-Field: tun_id tun_src tun_dst tun_ipv6_src tun_ipv6_dst tun_flags tun_gbp_id tun_gbp_flags tun_metadata0 dnl
tun_metadata1 tun_metadata2 tun_metadata3 tun_metadata4 tun_metadata5 tun_metadata6 tun_metadata7 tun_metadata8 tun_metadata9 tun_metadata10 tun_metadata11 tun_metadata12 tun_metadata13 tun_metadata14 tun_metadata15 tun_metadata16 tun_metadata17 tun_metadata18 tun_metadata19 tun_metadata20 tun_metadata21 tun_metadata22 tun_metadata23 tun_metadata24 tun_metadata25 tun_metadata26 tun_metadata27 tun_metadata28 tun_metadata29 tun_metadata30 tun_metadata31 tun_metadata32 tun_metadata33 tun_metadata34 tun_metadata35 tun_metadata36 tun_metadata37 tun_metadata38 tun_metadata39 tun_metadata40 tun_metadata41 tun_metadata42 tun_metadata43 tun_metadata44 tun_metadata45 tun_metadata46 tun_metadata47 tun_metadata48 tun_metadata49 tun_metadata50 tun_metadata51 tun_metadata52 tun_metadata53 tun_metadata54 tun_metadata55 tun_metadata56 tun_metadata57 tun_metadata58 tun_metadata59 tun_metadata60 tun_metadata61 tun_metadata62 tun_metadata63 dnl
metadata in_port in_port_oxm pkt_mark ct_mark ct_label reg0 reg1 reg2 reg3 reg4 reg5 reg6 reg7 reg8 reg9 reg10 reg11 reg12 reg13 reg14 reg15 xreg0 xreg1 xreg2 xreg3 xreg4 xreg5 xreg6 xreg7 xxreg0 xxreg1 xxreg2 xxreg3 eth_src eth_dst vlan_tci vlan_vid vlan_pcp mpls_label mpls_tc mpls_ttl ip_src ip_dst ipv6_src ipv6_dst ipv6_label nw_tos ip_dscp nw_ecn nw_ttl arp_op arp_spa arp_tpa arp_sha arp_tha tcp_src tcp_dst udp_src udp_dst sctp_src sctp_dst icmp_type icmp_code icmpv6_type icmpv6_code nd_target nd_sll nd_tll nsh_flags nsh_spi nsh_si nsh_c1 nsh_c2 nsh_c3 nsh_c4 nsh_ttl
    matching:
      dp_hash: arbitrary mask
      recirc_id: exact match or wildcard
      packet_type: exact match or wildcard
      conj_id: exact match or wildcard
      tun_id: arbitrary mask
      tun_src: arbitrary mask
      tun_dst: arbitrary mask
      tun_ipv6_src: arbitrary mask
      tun_ipv6_dst: arbitrary mask
      tun_flags: arbitrary mask
      tun_gbp_id: arbitrary mask
      tun_gbp_flags: arbitrary mask
      tun_metadata0: arbitrary mask
      tun_metadata1: arbitrary mask
      tun_metadata2: arbitrary mask
      tun_metadata3: arbitrary mask
      tun_metadata4: arbitrary mask
      tun_metadata5: arbitrary mask
      tun_metadata6: arbitrary mask
      tun_metadata7: arbitrary mask
      tun_metadata8: arbitrary mask
      tun_metadata9: arbitrary mask
      tun_metadata10: arbitrary mask
      tun_metadata11: arbitrary mask
      tun_metadata12: arbitrary mask
      tun_metadata13: arbitrary mask
      tun_metadata14: arbitrary mask
      tun_metadata15: arbitrary mask
      tun_metadata16: arbitrary mask
      tun_metadata17: arbitrary mask
      tun_metadata18: arbitrary mask
      tun_metadata19: arbitrary mask
      tun_metadata20: arbitrary mask
      tun_metadata21: arbitrary mask
      tun_metadata22: arbitrary mask
      tun_metadata23: arbitrary mask
      tun_metadata24: arbitrary mask
      tun_metadata25: arbitrary mask
      tun_metadata26: arbitrary mask
      tun_metadata27: arbitrary mask
      tun_metadata28: arbitrary mask
      tun_metadata29: arbitrary mask
      tun_metadata30: arbitrary mask
      tun_metadata31: arbitrary mask
      tun_metadata32: arbitrary mask
      tun_metadata33: arbitrary mask
      tun_metadata34: arbitrary mask
      tun_metadata35: arbitrary mask
      tun_metadata36: arbitrary mask
      tun_metadata37: arbitrary mask
      tun_metadata38: arbitrary mask
      tun_metadata39: arbitrary mask
      tun_metadata40: arbitrary mask
      tun_metadata41: arbitrary mask
      tun_metadata42: arbitrary mask
      tun_metadata43: arbitrary mask
      tun_metadata44: arbitrary mask
      tun_metadata45: arbitrary mask
      tun_metadata46: arbitrary mask
      tun_metadata47: arbitrary mask
      tun_metadata48: arbitrary mask
      tun_metadata49: arbitrary mask
      tun_metadata50: arbitrary mask
      tun_metadata51: arbitrary mask
      tun_metadata52: arbitrary mask
      tun_metadata53: arbitrary mask
      tun_metadata54: arbitrary mask
      tun_metadata55: arbitrary mask
      tun_metadata56: arbitrary mask
      tun_metadata57: arbitrary mask
      tun_metadata58: arbitrary mask
      tun_metadata59: arbitrary mask
      tun_metadata60: arbitrary mask
      tun_metadata61: arbitrary mask
      tun_metadata62: arbitrary mask
      tun_metadata63: arbitrary mask
      metadata: arbitrary mask
      in_port: exact match or wildcard
      in_port_oxm: exact match or wildcard
      actset_output: exact match or wildcard
      pkt_mark: arbitrary mask
      ct_state: arbitrary mask
      ct_zone: exact match or wildcard
      ct_mark: arbitrary mask
      ct_label: arbitrary mask
      ct_nw_proto: exact match or wildcard
      ct_nw_src: arbitrary mask
      ct_nw_dst: arbitrary mask
      ct_ipv6_src: arbitrary mask
      ct_ipv6_dst: arbitrary mask
      ct_tp_src: arbitrary mask
      ct_tp_dst: arbitrary mask
      reg0: arbitrary mask
      reg1: arbitrary mask
      reg2: arbitrary mask
      reg3: arbitrary mask
      reg4: arbitrary mask
      reg5: arbitrary mask
      reg6: arbitrary mask
      reg7: arbitrary mask
      reg8: arbitrary mask
      reg9: arbitrary mask
      reg10: arbitrary mask
      reg11: arbitrary mask
      reg12: arbitrary mask
      reg13: arbitrary mask
      reg14: arbitrary mask
      reg15: arbitrary mask
      xreg0: arbitrary mask
      xreg1: arbitrary mask
      xreg2: arbitrary mask
      xreg3: arbitrary mask
      xreg4: arbitrary mask
      xreg5: arbitrary mask
      xreg6: arbitrary mask
      xreg7: arbitrary mask
      xxreg0: arbitrary mask
      xxreg1: arbitrary mask
      xxreg2: arbitrary mask
      xxreg3: arbitrary mask
      eth_src: arbitrary mask
      eth_dst: arbitrary mask
      eth_type: exact match or wildcard
      vlan_tci: arbitrary mask
      vlan_vid: arbitrary mask
      vlan_pcp: exact match or wildcard
      mpls_label: exact match or wildcard
      mpls_tc: exact match or wildcard
      mpls_bos: exact match or wildcard
      mpls_ttl: exact match or wildcard
      ip_src: arbitrary mask
      ip_dst: arbitrary mask
      ipv6_src: arbitrary mask
      ipv6_dst: arbitrary mask
      ipv6_label: arbitrary mask
      nw_proto: exact match or wildcard
      nw_tos: exact match or wildcard
      ip_dscp: exact match or wildcard
      nw_ecn: exact match or wildcard
      nw_ttl: exact match or wildcard
      ip_frag: arbitrary mask
      arp_op: exact match or wildcard
      arp_spa: arbitrary mask
      arp_tpa: arbitrary mask
      arp_sha: arbitrary mask
      arp_tha: arbitrary mask
      tcp_src: arbitrary mask
      tcp_dst: arbitrary mask
      tcp_flags: arbitrary mask
      udp_src: arbitrary mask
      udp_dst: arbitrary mask
      sctp_src: arbitrary mask
      sctp_dst: arbitrary mask
      icmp_type: exact match or wildcard
      icmp_code: exact match or wildcard
      icmpv6_type: exact match or wildcard
      icmpv6_code: exact match or wildcard
      nd_target: arbitrary mask
      nd_sll: arbitrary mask
      nd_tll: arbitrary mask
      nsh_flags: arbitrary mask
      nsh_mdtype: exact match or wildcard
      nsh_np: exact match or wildcard
      nsh_spi: exact match or wildcard
      nsh_si: exact match or wildcard
      nsh_c1: arbitrary mask
      nsh_c2: arbitrary mask
      nsh_c3: arbitrary mask
      nsh_c4: arbitrary mask
      nsh_ttl: exact match or wildcard

' "$1"
}
ditto() {
    printf '  table %d:
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    max_entries=%d
    instructions (table miss and others):
      next tables: %d-253
      (same instructions)
      (same actions)
    (same matching)

' $1 $2 `expr $1 + 1`
}
tail_tables() {
echo '  table 252:
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    max_entries=1000000
    instructions (table miss and others):
      next tables: 253
      (same instructions)
      (same actions)
    (same matching)

  table 253:
    metadata: match=0xffffffffffffffff write=0xffffffffffffffff
    max_entries=1000000
    instructions (table miss and others):
      instructions: meter,apply_actions,clear_actions,write_actions,write_metadata
      (same actions)
    (same matching)
'
}
(head_table
 for i in `seq 1 251`; do
     ditto $i 1000000
 done
 tail_tables) > expout
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-table-features br0], [0], [expout])
# Change the configuration.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=main \
     -- --id=@t1 create Flow_Table flow-limit=1024 \
     -- set bridge br0 'flow_tables={1=@t1,0=@t0}' \
   | uuidfilt],
  [0], [<0>
<1>
])
# Check that the configuration was updated.
(head_table ' ("main")'
 ditto 1 1024
 for i in `seq 2 251`; do
     ditto $i 1000000
 done
 tail_tables) > expout
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-table-features br0], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow table names])
OVS_VSWITCHD_START
add_of_ports br0 1 2
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=zero \
     -- --id=@t1 create Flow_Table name=one \
     -- --id=@t2 create Flow_Table name=two \
     -- set bridge br0 'flow_tables={0=@t0,1=@t1,2=@t2}' \
   | uuidfilt],
  [0], [<0>
<1>
<2>
])
AT_DATA([flows.txt], [dnl
table=zero in_port=p2 actions=p1,resubmit(,one)
table=one,in_port=p1,ip,actions=ct(table=two)
table=one,in_port=p1,arp,actions=goto_table(two)
])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl --names --no-stats dump-flows br0], [0], [dnl
 table=zero, in_port=p2 actions=output:p1,resubmit(,one)
 table=one, ip,in_port=p1 actions=ct(table=two)
 table=one, arp,in_port=p1 actions=resubmit(,two)
])
AT_CHECK([ovs-ofctl --no-names --no-stats dump-flows br0], [0], [dnl
 in_port=2 actions=output:1,resubmit(,1)
 table=1, ip,in_port=1 actions=ct(table=2)
 table=1, arp,in_port=1 actions=resubmit(,2)
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - table description (OpenFlow 1.4)])
OVS_VSWITCHD_START
(x=0
 while test $x -lt 254; do
   y=`expr $x + 1`
   echo "  table $x:
   eviction=off eviction_flags=OTHER|IMPORTANCE|LIFETIME
   vacancy=off"
   x=$y
 done) > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-table-desc br0 | sed '/^$/d
/^OFPST_TABLE_DESC/d'], [0], [expout])

# Change the configuration.
AT_CHECK([ovs-ofctl -O Openflow14 mod-table br0 0 evict])
# Check that the configuration was updated.
mv expout orig-expout
sed -e '2s/eviction=off/eviction=on/' <orig-expout > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-table-desc br0 | sed '/^$/d
/^OFPST_TABLE_DESC/d'], [0], [expout])

AT_CHECK([ovs-ofctl -O Openflow14 mod-table br0 0 vacancy:20,80])
# Check that the configuration was updated.
mv expout orig-expout
sed -e '3s/vacancy=off/vacancy=on vacancy_down=20% vacancy_up=80% vacancy=100%/' <orig-expout > expout
AT_CHECK([ovs-ofctl -O OpenFlow14 dump-table-desc br0 | sed '/^$/d
/^OFPST_TABLE_DESC/d'], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - hard limits on flow table size (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
for in_port in 1 2 3 4; do
    ovs-ofctl add-flow br0 in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=drop
 in_port=4 actions=drop
NXST_FLOW reply:
])
# Adding another flow will be refused.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD: ADD in_port=5 actions=drop
])
# Also a mod-flow that would add a flow will be refused.
AT_CHECK([ovs-ofctl mod-flows br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD: MOD in_port=5 actions=drop
])
# Replacing or modifying an existing flow is allowed.
AT_CHECK([ovs-ofctl add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=output:1
 in_port=4 actions=NORMAL
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - hard limits on flow table size (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
for in_port in 1 2 3 4; do
    ovs-ofctl -O OpenFlow12 add-flow br0 in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=drop
 in_port=4 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will be refused.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
  [OFPT_ERROR (OF1.2): OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD (OF1.2): ADD in_port=5 actions=drop
])
# Replacing or modifying an existing flow is allowed.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=output:1
 in_port=4 actions=NORMAL
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 idle_timeout=${in_port}0,in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=1 actions=drop
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
NXST_FLOW reply:
])
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
 in_port=5 actions=drop
NXST_FLOW reply:
])
# A mod-flow that adds a flow also causes eviction, but replacing or
# modifying an existing flow doesn't.
AT_CHECK([ovs-ofctl mod-flows br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=3 actions=output:1
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
 in_port=6 actions=drop
NXST_FLOW reply:
])
# Flows with no timeouts at all cannot be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=7,actions=normal])
AT_CHECK([ovs-ofctl add-flow br0 in_port=8,actions=drop], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD: ADD in_port=8 actions=drop
])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
 in_port=6 actions=drop
 in_port=7 actions=NORMAL
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl -O OpenFlow12 add-flow br0 idle_timeout=${in_port}0,in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=1 actions=drop
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
 in_port=5 actions=drop
OFPST_FLOW reply (OF1.2):
])
# In OpenFlow 1.2 a mod-flow does not ever add a flow and thus
# has no effect on eviction
AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=output:1
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Flows with no timeouts at all cannot be evicted.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=7,actions=normal])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=8,actions=drop], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
  [OFPT_ERROR (OF1.2): OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD (OF1.2): ADD in_port=8 actions=drop
])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
 in_port=6 actions=drop
 in_port=7 actions=NORMAL
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction using importance upon table overflow (OpenFlow 1.4)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=evict flow-limit=4 \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Use mod-table to turn on eviction just to demonstrate that it works.
AT_CHECK([ovs-ofctl -O OpenFlow14 mod-table br0 0 evict])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl -O Openflow14 add-flow br0 importance=$((in_port + 30)),priority=$((in_port + 5)),hard_timeout=$((in_port + 500)),actions=drop
done
AT_CHECK([ovs-ofctl -O Openflow14 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=501, importance=31, priority=6 actions=drop
 hard_timeout=502, importance=32, priority=7 actions=drop
 hard_timeout=503, importance=33, priority=8 actions=drop
 hard_timeout=504, importance=34, priority=9 actions=drop
OFPST_FLOW reply (OF1.4):
])
# Adding another flow will cause the one with lowest importance to be evicted.
AT_CHECK([ovs-ofctl -O Openflow14 add-flow br0 hard_timeout=505,importance=35,priority=10,in_port=2,actions=drop])
AT_CHECK([ovs-ofctl -O Openflow14 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=502, importance=32, priority=7 actions=drop
 hard_timeout=503, importance=33, priority=8 actions=drop
 hard_timeout=504, importance=34, priority=9 actions=drop
 hard_timeout=505, importance=35, priority=10,in_port=2 actions=drop
OFPST_FLOW reply (OF1.4):
])
# Disable the Eviction configuration.
AT_CHECK([ovs-ofctl -O OpenFlow14 mod-table br0 0 noevict])
# Adding another flow will cause the system to give error for FULL TABLE.
AT_CHECK([ovs-ofctl -O Openflow14 add-flow br0 hard_timeout=506,importance=36,priority=11,actions=drop],[1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
 [OFPT_ERROR (OF1.4): OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD (OF1.4): ADD priority=11 hard:506 importance:36 actions=drop
])
#Dump flows. It should show only the old values
AT_CHECK([ovs-ofctl -O Openflow14 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=502, importance=32, priority=7 actions=drop
 hard_timeout=503, importance=33, priority=8 actions=drop
 hard_timeout=504, importance=34, priority=9 actions=drop
 hard_timeout=505, importance=35, priority=10,in_port=2 actions=drop
OFPST_FLOW reply (OF1.4):
])
# mod-flow that would modify a flow will be done successfully.
AT_CHECK([ovs-ofctl -O Openflow14 mod-flows br0 in_port=2,actions=NORMAL])
AT_CHECK([ovs-ofctl -O Openflow14 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=502, importance=32, priority=7 actions=drop
 hard_timeout=503, importance=33, priority=8 actions=drop
 hard_timeout=504, importance=34, priority=9 actions=drop
 hard_timeout=505, importance=35, priority=10,in_port=2 actions=NORMAL
OFPST_FLOW reply (OF1.4):
])
# Also a mod-flow that would add a flow will be refused.
AT_CHECK([ovs-ofctl mod-flows br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([ofctl_strip < stderr], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
OFPT_FLOW_MOD: MOD in_port=5 actions=drop
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with fairness (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=evict flow-limit=4 \
                                   overflow-policy=evict \
                                   groups='"NXM_OF_IN_PORT[[]]"' \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
ovs-ofctl add-flows br0 - <<EOF
idle_timeout=10 in_port=2 dl_src=00:44:55:66:77:88 actions=drop
idle_timeout=20 in_port=1 dl_src=00:11:22:33:44:55 actions=drop
idle_timeout=30 in_port=1 dl_src=00:22:33:44:55:66 actions=drop
idle_timeout=40 in_port=1 dl_src=00:33:44:55:66:77 actions=drop
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=20, in_port=1,dl_src=00:11:22:33:44:55 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
NXST_FLOW reply:
])
# Adding another flow will cause the one that expires soonest within
# the largest group (those with in_port=1) to be evicted.  In this
# case this is not the same as the one that expires soonest overall
# (which is what makes the test interesting):
AT_CHECK([ovs-ofctl add-flow br0 in_port=2,dl_src=00:55:66:77:88:99,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
# Enlarge the flow limit, change the eviction policy back to strictly
# based on expiration, and and add some flows.
AT_CHECK([ovs-vsctl set Flow_Table evict groups='[[]]' flow-limit=7])
ovs-ofctl add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=drop
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=drop
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=drop
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
# Adding another flow will cause the one that expires soonest overall
# to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 'idle_timeout=80 in_port=2 dl_src=00:99:aa:bb:cc:dd actions=drop'])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
# Reducing the flow limit also causes the flows that expire soonest
# overall to be evicted.
AT_CHECK([ovs-vsctl set Flow_Table evict flow-limit=4])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with fairness (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=evict flow-limit=4 \
                                   overflow-policy=evict \
                                   groups='"NXM_OF_IN_PORT[[]]"' \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
ovs-ofctl -O OpenFlow12 add-flows br0 - <<EOF
idle_timeout=10 in_port=2 dl_src=00:44:55:66:77:88 actions=drop
idle_timeout=20 in_port=1 dl_src=00:11:22:33:44:55 actions=drop
idle_timeout=30 in_port=1 dl_src=00:22:33:44:55:66 actions=drop
idle_timeout=40 in_port=1 dl_src=00:33:44:55:66:77 actions=drop
EOF
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=20, in_port=1,dl_src=00:11:22:33:44:55 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest within
# the largest group (those with in_port=1) to be evicted.  In this
# case this is not the same as the one that expires soonest overall
# (which is what makes the test interesting):
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=2,dl_src=00:55:66:77:88:99,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Enlarge the flow limit, change the eviction policy back to strictly
# based on expiration, and and add some flows.
AT_CHECK([ovs-vsctl set Flow_Table evict groups='[[]]' flow-limit=7])
ovs-ofctl -O OpenFlow12 add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=drop
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=drop
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=drop
EOF
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest overall
# to be evicted.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 'idle_timeout=80 in_port=2 dl_src=00:99:aa:bb:cc:dd actions=drop'])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Reducing the flow limit also causes the flows that expire soonest
# overall to be evicted.
AT_CHECK([ovs-vsctl set Flow_Table evict flow-limit=4])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with modified hard timeout])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
ovs-appctl time/stop
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 hard_timeout=$((10 + in_port * 3)),in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=13, in_port=1 actions=drop
 hard_timeout=16, in_port=2 actions=drop
 hard_timeout=19, in_port=3 actions=drop
 hard_timeout=22, in_port=4 actions=drop
NXST_FLOW reply:
])
# Sleep and modify the one that expires soonest
ovs-appctl time/warp 5000
AT_CHECK([ovs-ofctl mod-flows br0 in_port=1,actions=drop])
# At this point the table would looks like:
#  in_port   seconds to expire
#     1            13
#     2            11
#     3            14
#     4            17
ovs-appctl time/warp 2000
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=13, in_port=1 actions=drop
 hard_timeout=19, in_port=3 actions=drop
 hard_timeout=22, in_port=4 actions=drop
 in_port=5 actions=drop
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with modified idle timeout])
OVS_VSWITCHD_START([add-port br0 p1 -- set interface p1 type=dummy ofport_request=1])
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | uuidfilt],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 idle_timeout=$((10 + in_port * 3)),in_port=$in_port,actions=drop
done
ovs-appctl time/stop
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=13, in_port=1 actions=drop
 idle_timeout=16, in_port=2 actions=drop
 idle_timeout=19, in_port=3 actions=drop
 idle_timeout=22, in_port=4 actions=drop
NXST_FLOW reply:
])
# Sleep and receive on the flow that expires soonest
ovs-appctl time/warp 5000
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1)'])
# At this point the table would looks like:
#  in_port   seconds to expire
#     1            13
#     2            11
#     3            14
#     4            17
ovs-appctl time/warp 2000
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=19, in_port=3 actions=drop
 idle_timeout=22, in_port=4 actions=drop
 in_port=5 actions=drop
 n_packets=1, n_bytes=14, idle_timeout=13, in_port=1 actions=drop
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -P standard monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    ovs-ofctl -v packet-out br0 controller controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -v packet-out br0 controller 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via no_match) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl packet-out br0 "in_port=controller packet=002583dfb4000026b98cb0f908004500003eb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00 actions=dec_ttl"
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN: total_len=76 in_port=CONTROLLER (via invalid_ttl) data_len=76 (unbuffered)
udp,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy ofport_request=1
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS: ADD: 1(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS: DEL: 1(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED:  reason=delete"
    fi
    AT_FAIL_IF([test X"$1" != X])

    OVS_WAIT_UNTIL([test `wc -l < "monitor.log"` -ge `wc -l < "expout"`])

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Set miss_send_len to 128 and enable invalid_ttl.
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700040080
check_async 3 OFPR_ACTION OFPR_INVALID_TTL OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Become slave, which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 0104001400000002000023200000000a00000002
check_async 4 OFPPR_ADD OFPPR_DELETE

# Use NXT_SET_ASYNC_CONFIG to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 01040028000000020000232000000013000000020000000500000005000000020000000200000005
check_async 5 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 01040018000000030000232000000014000000000000007b
check_async 6 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 010400180000000300002320000000140000000000000000

# Become master.
ovs-appctl -t ovs-ofctl ofctl/send 0104001400000002000023200000000a00000001
check_async 7 OFPR_ACTION OFPPR_ADD

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -P standard monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    ovs-ofctl -O OpenFlow12 -v packet-out br0 none controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -O OpenFlow12 -v packet-out br0 none 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY (via no_match) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl -O OpenFlow12 packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003eb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=76 in_port=ANY (via invalid_ttl) data_len=76 (unbuffered)
udp,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.2): ADD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.2): DEL: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl -O OpenFlow12 add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl -O OpenFlow12 --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.2):  reason=delete table_id=0"
    fi
    AT_FAIL_IF([test X"$1" != X])

    OVS_WAIT_UNTIL([test `wc -l < "monitor.log"` -ge `wc -l < "expout"`])

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Set miss_send_len to 128 and enable invalid_ttl.
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700040080
check_async 3 OFPR_ACTION OFPR_INVALID_TTL OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Become slave (OF 1.2), which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 031800180000000200000003000000000000000000000001
check_async 4 OFPPR_ADD OFPPR_DELETE

# Use NXT_SET_ASYNC_CONFIG to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 03040028000000020000232000000013000000020000000500000005000000020000000200000005
check_async 5 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 03040018000000030000232000000014000000000000007b
check_async 6 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 030400180000000300002320000000140000000000000000

# Become master (OF 1.2).
ovs-appctl -t ovs-ofctl ofctl/send 031800180000000400000002000000000000000000000002
check_async 7 OFPR_ACTION OFPPR_ADD

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.3)])
OVS_VSWITCHD_START([dnl
    add-port br0 p1 -- set Interface p1 type=dummy ofport_request=10
])
AT_CHECK([ovs-ofctl -O OpenFlow13 -P standard monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    # OFPR_ACTION_SET is treated as OFPR_ACTION in OpenFlow 1.3
    ovs-ofctl -O OpenFlow13 -v packet-out br0 none controller '0001020304050010203040501234'
    ovs-ofctl -O OpenFlow13 add-flow br0 'in_port=10 actions=write_actions(output(CONTROLLER))'
    ovs-appctl netdev-dummy/receive p1 'in_port(10),eth(src=00:10:20:30:40:50,dst=00:01:02:03:04:05),eth_type(0x1234)'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.3): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
        echo >>expout "OFPT_PACKET_IN (OF1.3): cookie=0x0 total_len=14 in_port=10 (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -O OpenFlow13 -v packet-out br0 none 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.3): total_len=14 in_port=ANY (via no_match) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl -O OpenFlow13 packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003eb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.3): total_len=76 in_port=ANY (via invalid_ttl) data_len=76 (unbuffered)
udp,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.3): ADD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.3): DEL: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl -O OpenFlow13 add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl -O OpenFlow13 --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.3):  reason=delete table_id=0"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_GROUP_DELETE
    ovs-ofctl -O OpenFlow13 add-group br0 group_id=1234,type=all,bucket=output:10
    ovs-ofctl -O OpenFlow13 add-flow br0 send_flow_rem,actions=group:1234
    ovs-ofctl -O OpenFlow13 --strict del-groups br0 group_id=1234
    if test X"$1" = X"OFPRR_GROUP_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.3):  reason=group_delete table_id=0"
    fi

    AT_FAIL_IF([test X"$1" != X])

    OVS_WAIT_UNTIL([test `wc -l < "monitor.log"` -ge `wc -l < "expout"`])

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0409000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE OFPRR_GROUP_DELETE

# Become slave (OF 1.3), which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 041800180000000200000003000000000000000000000001
check_async 3 OFPPR_ADD OFPPR_DELETE

# Use OF 1.3 OFPT_SET_ASYNC to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 041c00200000000200000002000000050000000500000002000000020000000d
check_async 4 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE OFPRR_GROUP_DELETE

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 04040018000000030000232000000014000000000000007b
check_async 5 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE OFPRR_GROUP_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 040400180000000300002320000000140000000000000000

# Become master (OF 1.3).
ovs-appctl -t ovs-ofctl ofctl/send 041800180000000400000002000000000000000000000002
check_async 6 OFPR_ACTION OFPPR_ADD

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.4)])
OVS_VSWITCHD_START([dnl
    add-port br0 p1 -- set Interface p1 type=dummy ofport_request=10
])
AT_CHECK([ovs-ofctl -O OpenFlow14 -P standard monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_PACKET_OUT (controller_id=0)
    ovs-ofctl -O OpenFlow14 -v packet-out br0 none controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_PACKET_OUT"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.4): total_len=14 in_port=ANY (via packet_out) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_ACTION_SET (controller_id=0)
    ovs-ofctl -O OpenFlow14 add-flow br0 'in_port=10 actions=write_actions(output(CONTROLLER))'
    ovs-appctl netdev-dummy/receive p1 'in_port(10),eth(src=00:10:20:30:40:50,dst=00:01:02:03:04:05),eth_type(0x1234)'
    if test X"$1" = X"OFPR_ACTION_SET"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.4): cookie=0x0 total_len=14 in_port=10 (via action_set) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -O OpenFlow14 -v packet-out br0 none 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.4): total_len=14 in_port=ANY (via no_match) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl -O OpenFlow14 packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003eb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.4): total_len=76 in_port=ANY (via invalid_ttl) data_len=76 (unbuffered)
udp,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

# OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.4): ADD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_MODIFY
    ovs-ofctl -O OpenFlow14 -vwarn mod-port br0 test up
    if test X"$1" = X"OFPPR_MODIFY"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.4): MOD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     0
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_PORT_STATUS (OF1.4): MOD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     0
     state:      LIVE
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.4): DEL: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     0
     state:      LIVE
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl -O OpenFlow14 add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl -O OpenFlow14 --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.4):  reason=delete table_id=0"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_GROUP_DELETE
    ovs-ofctl -O OpenFlow14 add-group br0 group_id=1234,type=all,bucket=output:10
    ovs-ofctl -O OpenFlow14 add-flow br0 send_flow_rem,actions=group:1234
    ovs-ofctl -O OpenFlow14 --strict del-groups br0 group_id=1234
    if test X"$1" = X"OFPRR_GROUP_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.4):  reason=group_delete table_id=0"
    fi

    # OFPT_TABLE_STATUS, OFPTR_VACANCY_UP
    if test X"$1" = X"OFPTR_VACANCY_UP"; then shift;
        ovs-vsctl -- --id=@t1 create Flow_Table flow-limit=10 -- set bridge br0 flow_tables:1=@t1

	# Turn on vacancy events, then add flows until we're full.
	# With initial vacancy of 100% and vacancy_up of 80%, so that
	# vacancy >= vacancy_up, this enables VACANY_DOWN events, so
	# we get a single such message when vacancy dips below 20%.
        ovs-ofctl -O OpenFlow14 mod-table br0 1 vacancy:20,80
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=1,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=2,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=3,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=4,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=5,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=6,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=7,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=8,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=9,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=10,actions=2
        echo >>expout "OFPT_TABLE_STATUS (OF1.4): reason=VACANCY_DOWN
table_desc:-
  table 1:
   eviction=off eviction_flags=OTHER|IMPORTANCE|LIFETIME
   vacancy=on vacancy_down=20% vacancy_up=80% vacancy=10%"
        # Then delete flows until we're empty.  Sending the
	# VACANCY_DOWN message enabled VACANCY_UP events, so we get a
	# single such message when vacancy rises above 80%.
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=1
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=2
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=3
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=4
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=5
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=6
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=7
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=8
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=9
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=10
        echo >>expout "OFPT_TABLE_STATUS (OF1.4): reason=VACANCY_UP
table_desc:-
  table 1:
   eviction=off eviction_flags=OTHER|IMPORTANCE|LIFETIME
   vacancy=on vacancy_down=20% vacancy_up=80% vacancy=90%"

        # Now approach vacancy from the other direction.  First
	# disable vacancy events.  With initial vacancy of 70%, so
	# that vacancy < vacancy_up, this enables VACANCY_UP events.
	# That means that filling up the table generates no message,
	# but deleting all the flows generates VACANCY_UP at the point
	# vacancy rises above 80%.
        ovs-ofctl -O OpenFlow14 mod-table br0 1 novacancy
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=1,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=2,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=3,actions=2
        ovs-ofctl -O OpenFlow14 mod-table br0 1 vacancy:20,80
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=4,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=5,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=6,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=7,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=8,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=9,actions=2
        ovs-ofctl -O OpenFlow14 add-flow br0 table=1,in_port=10,actions=2
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=1
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=2
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=3
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=4
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=5
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=6
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=7
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=8
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=9
        ovs-ofctl -O OpenFlow14 del-flows br0 table=1,in_port=10
        echo >>expout "OFPT_TABLE_STATUS (OF1.4): reason=VACANCY_UP
table_desc:-
  table 1:
   eviction=off eviction_flags=OTHER|IMPORTANCE|LIFETIME
   vacancy=on vacancy_down=20% vacancy_up=80% vacancy=90%"
    fi

    AT_FAIL_IF([test X"$1" != X])

    OVS_WAIT_UNTIL([test `wc -l < "monitor.log"` -ge `wc -l < "expout"`])

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0509000c0123456700000080
check_async 2 OFPR_PACKET_OUT OFPR_ACTION_SET OFPPR_ADD OFPPR_MODIFY OFPPR_DELETE OFPRR_DELETE OFPRR_GROUP_DELETE

# Become slave (OF 1.4), which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 051800180000000200000003000000000000000000000001
check_async 3 OFPPR_ADD OFPPR_MODIFY OFPPR_DELETE

# Use OF 1.4 OFPT_SET_ASYNC to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 051c0040000000020000000800000005000100080000002000020008000000020003000800000005000400080000001c00050008000000050008000800000018
check_async 4 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE OFPRR_GROUP_DELETE OFPTR_VACANCY_UP

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 05040018000000030000232000000014000000000000007b
check_async 5 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE OFPRR_GROUP_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 050400180000000300002320000000140000000000000000

# Become master (OF 1.4).
ovs-appctl -t ovs-ofctl ofctl/send 051800180000000400000002000000000000000000000002
check_async 6 OFPR_PACKET_OUT OFPPR_ADD OFPPR_MODIFY OFPRR_DELETE

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.5)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow15 -P standard monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # Other tests are not working with OF 1.5, and message
    # format may change, so leave them out.

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.5): ADD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_MODIFY
    ovs-ofctl -O OpenFlow15 -vwarn mod-port br0 test up
    if test X"$1" = X"OFPPR_MODIFY"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.5): MOD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     0
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_PORT_STATUS (OF1.5): MOD: 2(test): addr:aa:55:aa:55:00:0x
     config:     0
     state:      LIVE
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.5): DEL: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     0
     state:      LIVE
     speed: 0 Mbps now, 0 Mbps max"
    fi

    AT_FAIL_IF([test X"$1" != X])

    OVS_WAIT_UNTIL([test `wc -l < "monitor.log"` -ge `wc -l < "expout"`])

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# If we don't set this, async messages are not received.
# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0609000c0123456700000080
check_async 2 OFPPR_ADD OFPPR_MODIFY OFPPR_DELETE

# Set-async has changed in OF 1.4 and is not yet implemented.

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that the role request/response messaging works
dnl and that generation_id is handled properly.
AT_SETUP([ofproto - controller role (OpenFlow 1.2)])
OVS_VSWITCHD_START
on_exit 'kill `cat c1.pid c2.pid`'

# Start two ovs-ofctl controller processes.
AT_CAPTURE_FILE([monitor1.log])
AT_CAPTURE_FILE([expout1])
AT_CAPTURE_FILE([experr1])
AT_CAPTURE_FILE([monitor2.log])
AT_CAPTURE_FILE([expout2])
AT_CAPTURE_FILE([experr2])
for i in 1 2; do
     AT_CHECK([ovs-ofctl -O OpenFlow12 monitor br0 --detach --no-chdir --pidfile=c$i.pid --unixctl=c$i])
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    ovs-appctl -t `pwd`/c$i ofctl/set-output-file monitor$i.log
    : > expout$i
    : > experr$i

    # find out current role
    ovs-appctl -t `pwd`/c$i ofctl/send 031800180000000200000000000000000000000000000000
    echo >>experr$i "send: OFPT_ROLE_REQUEST (OF1.2): role=nochange"
    echo >>expout$i "OFPT_ROLE_REPLY (OF1.2): role=equal"
done

# controller 1: Become slave (generation_id is initially undefined, so
# 2^63+2 should not be stale)
ovs-appctl -t `pwd`/c1 ofctl/send 031800180000000300000003000000008000000000000002
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.2): role=slave generation_id=9223372036854775810"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.2): role=slave generation_id=9223372036854775810"

# controller 2: Become master.
ovs-appctl -t `pwd`/c2 ofctl/send 031800180000000300000002000000008000000000000003
echo >>experr2 "send: OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=9223372036854775811"
echo >>expout2 "OFPT_ROLE_REPLY (OF1.2): role=master generation_id=9223372036854775811"

# controller 1: Try to become the master using a stale generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 031800180000000400000002000000000000000000000003
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=3"
echo >>expout1 "OFPT_ERROR (OF1.2): OFPRRFC_STALE"
echo >>expout1 "OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=3"

# controller 1: Become master using a valid generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 031800180000000500000002000000000000000000000001
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=1"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.2): role=master generation_id=1"

for i in 1 2; do
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    echo >>expout$i "OFPT_BARRIER_REPLY (OF1.2):"
done

# Check output.
for i in 1 2; do
    cp expout$i expout
    AT_CHECK([grep -v '^send:' monitor$i.log | strip_xids], [0], [expout])
    cp experr$i expout
    AT_CHECK([grep '^send:' monitor$i.log | strip_xids], [0], [expout])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that the role request/response messaging works,
dnl that generation_id is handled properly, and that role status update
dnl messages are sent when a controller's role gets changed from master
dnl to slave.
AT_SETUP([ofproto - controller role (OpenFlow 1.4)])
OVS_VSWITCHD_START
on_exit 'kill `cat c1.pid c2.pid`'

# Start two ovs-ofctl controller processes.
AT_CAPTURE_FILE([monitor1.log])
AT_CAPTURE_FILE([expout1])
AT_CAPTURE_FILE([experr1])
AT_CAPTURE_FILE([monitor2.log])
AT_CAPTURE_FILE([expout2])
AT_CAPTURE_FILE([experr2])
for i in 1 2; do
     AT_CHECK([ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile=c$i.pid --unixctl=c$i])
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    ovs-appctl -t `pwd`/c$i ofctl/set-output-file monitor$i.log
    : > expout$i
    : > experr$i

    # find out current role
    ovs-appctl -t `pwd`/c$i ofctl/send 051800180000000200000000000000000000000000000000
    echo >>experr$i "send: OFPT_ROLE_REQUEST (OF1.4): role=nochange"
    echo >>expout$i "OFPT_ROLE_REPLY (OF1.4): role=equal"
done

# controller 1: Become slave (generation_id is initially undefined, so
# 2^63+2 should not be stale)
ovs-appctl -t `pwd`/c1 ofctl/send 051800180000000300000003000000008000000000000002
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.4): role=slave generation_id=9223372036854775810"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.4): role=slave generation_id=9223372036854775810"

# controller 2: Become master.
ovs-appctl -t `pwd`/c2 ofctl/send 051800180000000300000002000000008000000000000003
echo >>experr2 "send: OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=9223372036854775811"
echo >>expout2 "OFPT_ROLE_REPLY (OF1.4): role=master generation_id=9223372036854775811"

# controller 1: Try to become the master using a stale generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 051800180000000400000002000000000000000000000003
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=3"
echo >>expout1 "OFPT_ERROR (OF1.4): OFPRRFC_STALE"
echo >>expout1 "OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=3"

# controller 1: Become master using a valid generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 051800180000000500000002000000000000000000000001
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=1"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.4): role=master generation_id=1"
echo >>expout2 "OFPT_ROLE_STATUS (OF1.4): role=slave generation_id=1 reason=master_request"

for i in 1 2; do
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    echo >>expout$i "OFPT_BARRIER_REPLY (OF1.4):"
done

# Check output.
for i in 1 2; do
    cp expout$i expout
    AT_CHECK([grep -v '^send:' monitor$i.log | strip_xids], [0], [expout])
    cp experr$i expout
    AT_CHECK([grep '^send:' monitor$i.log | strip_xids], [0], [expout])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that the role request/response messaging works,
dnl that generation_id is handled properly, and that role status update
dnl messages are sent when a controller's role gets changed from master
dnl to slave.
AT_SETUP([ofproto - controller role (OpenFlow 1.3)])
OVS_VSWITCHD_START
on_exit 'kill `cat c1.pid c2.pid`'

# Start two ovs-ofctl controller processes.
AT_CAPTURE_FILE([monitor1.log])
AT_CAPTURE_FILE([expout1])
AT_CAPTURE_FILE([experr1])
AT_CAPTURE_FILE([monitor2.log])
AT_CAPTURE_FILE([expout2])
AT_CAPTURE_FILE([experr2])
for i in 1 2; do
     AT_CHECK([ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile=c$i.pid --unixctl=c$i])
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    ovs-appctl -t `pwd`/c$i ofctl/set-output-file monitor$i.log
    : > expout$i
    : > experr$i

    # find out current role
    ovs-appctl -t `pwd`/c$i ofctl/send 041800180000000200000000000000000000000000000000
    echo >>experr$i "send: OFPT_ROLE_REQUEST (OF1.3): role=nochange"
    echo >>expout$i "OFPT_ROLE_REPLY (OF1.3): role=equal"
done

# controller 1: Become slave (generation_id is initially undefined, so
# 2^63+2 should not be stale)
ovs-appctl -t `pwd`/c1 ofctl/send 041800180000000300000003000000008000000000000002
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.3): role=slave generation_id=9223372036854775810"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.3): role=slave generation_id=9223372036854775810"

# controller 2: Become master.
ovs-appctl -t `pwd`/c2 ofctl/send 041800180000000300000002000000008000000000000003
echo >>experr2 "send: OFPT_ROLE_REQUEST (OF1.3): role=master generation_id=9223372036854775811"
echo >>expout2 "OFPT_ROLE_REPLY (OF1.3): role=master generation_id=9223372036854775811"

# controller 1: Try to become the master using a stale generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 041800180000000400000002000000000000000000000003
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.3): role=master generation_id=3"
echo >>expout1 "OFPT_ERROR (OF1.3): OFPRRFC_STALE"
echo >>expout1 "OFPT_ROLE_REQUEST (OF1.3): role=master generation_id=3"

# controller 1: Become master using a valid generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 041800180000000500000002000000000000000000000001
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.3): role=master generation_id=1"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.3): role=master generation_id=1"
echo >>expout2 "ONFT_ROLE_STATUS (OF1.3): role=slave generation_id=1 reason=master_request"

for i in 1 2; do
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    echo >>expout$i "OFPT_BARRIER_REPLY (OF1.3):"
done

# Check output.
for i in 1 2; do
    cp expout$i expout
    AT_CHECK([grep -v '^send:' monitor$i.log | strip_xids], [0], [expout])
    cp experr$i expout
    AT_CHECK([grep '^send:' monitor$i.log | strip_xids], [0], [expout])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks the Group and meter notifications when a group mod
dnl command is sent from one controller and the reply is received by
dnl other controllers.
AT_SETUP([ofproto - requestforward (OpenFlow 1.4)])
OVS_VSWITCHD_START
on_exit 'kill `cat c1.pid c2.pid c3.pid`'

# Start two ovs-ofctl controller processes.
AT_CAPTURE_FILE([monitor1.log])
AT_CAPTURE_FILE([expout1])
AT_CAPTURE_FILE([monitor2.log])
AT_CAPTURE_FILE([expout2])
AT_CAPTURE_FILE([monitor3.log])
AT_CAPTURE_FILE([expout3])

ovs-ofctl -O OpenFlow15 monitor br0 --detach --no-chdir --pidfile=c1.pid --unixctl=c1
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile=c2.pid --unixctl=c2
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile=c3.pid --unixctl=c3

check_async () {
    for i in 1 3; do
        ovs-appctl -t `pwd`/c$i ofctl/barrier
        ovs-appctl -t `pwd`/c$i ofctl/set-output-file monitor$i.log
        : > expout$i
    done

    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    # OFPGC_ADD
    ovs-appctl -t `pwd`/c2 ofctl/send "050f0020000000020000000000000001 00100000 ffffffffffffffff 00000000"
    if test X"$1" = X"OFPGC_ADD"; then shift;
        echo >>expout2 "send: OFPT_GROUP_MOD (OF1.4):
 ADD group_id=1,type=all,bucket=actions=drop"
        echo >>expout1 "OFPT_REQUESTFORWARD (OF1.5): reason=group_mod
 ADD group_id=1,type=all,bucket=bucket_id:0,actions=drop"
        echo >>expout3 "OFPT_REQUESTFORWARD (OF1.4): reason=group_mod
 ADD group_id=1,type=all,bucket=actions=drop"
    fi

    # OFPGC_MODIFY
    ovs-appctl -t `pwd`/c2 ofctl/send "050f0020000000020001010000000001 00100000 ffffffffffffffff 00000000"
    if test X"$1" = X"OFPGC_MODIFY"; then shift;
        echo >>expout2 "send: OFPT_GROUP_MOD (OF1.4):
 MOD group_id=1,type=select,bucket=weight:0,actions=drop"
        echo >>expout1 "OFPT_REQUESTFORWARD (OF1.5): reason=group_mod
 MOD group_id=1,type=select,bucket=bucket_id:0,weight:0,actions=drop"
        echo >>expout3 "OFPT_REQUESTFORWARD (OF1.4): reason=group_mod
 MOD group_id=1,type=select,bucket=weight:0,actions=drop"
    fi

    ovs-appctl -t `pwd`/c1 ofctl/barrier
    echo >>expout1 "OFPT_BARRIER_REPLY (OF1.5):"
    ovs-appctl -t `pwd`/c2 ofctl/barrier
    echo >>expout2 "OFPT_BARRIER_REPLY (OF1.4):"
    ovs-appctl -t `pwd`/c3 ofctl/barrier
    echo >>expout3 "OFPT_BARRIER_REPLY (OF1.4):"

    # Check output.
    for i in 1 3; do
        cp expout$i expout
        AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//'< monitor$i.log]],
      [0], [expout])
    done
}

# controller 1: Become slave
ovs-appctl -t `pwd`/c1 ofctl/send 061800180000000300000003000000008000000000000002

# controller 2: Become master
ovs-appctl -t `pwd`/c2 ofctl/send 051800180000000300000002000000008000000000000003

# controller 1: Become slave
ovs-appctl -t `pwd`/c3 ofctl/send 051800180000000300000003000000008000000000000004

# controller 1: Enabled requestforward using set Asynchronous message
ovs-appctl -t `pwd`/c1 ofctl/send 061c00280000000200000008000000050002000800000002000400080000001a000a000800000003

# controller 2: Enabled requestforward using set Asynchronous message
ovs-appctl -t `pwd`/c2 ofctl/send 051c002800000002000100080000000200030008000000050005000800000005000b000800000003

# controller 1: Enabled requestforward using set Asynchronous message
ovs-appctl -t `pwd`/c3 ofctl/send 051c00280000000200000008000000050002000800000002000400080000001a000a000800000003
check_async 1 OFPGC_ADD OFPGC_MODIFY

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.0) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.0)])
OVS_VSWITCHD_START
add_of_ports br0 1

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (65533) as in_port.
AT_CHECK([ovs-ofctl packet-out br0 "in_port=none packet=0001020304050010203040501234 actions=controller,1"])
AT_CHECK([ovs-ofctl packet-out br0 "in_port=controller packet=0001020304050010203040505678 actions=controller,1"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

ovs-ofctl dump-ports br0

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN: total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.2) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow12 -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (65533) as in_port.
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 none controller '0001020304050010203040501234'])
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 4294967293 controller '0001020304050010203040505678'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.1) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.1)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow11 -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0209000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER as in_port.
AT_CHECK([ovs-appctl -t ovs-ofctl ofctl/packet-out "in_port=none, packet=0001020304050010203040501234 actions=controller"])
AT_CHECK([ovs-appctl -t ovs-ofctl ofctl/packet-out "in_port=controller packet=0001020304050010203040505678 actions=controller"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//
/PACKET_OUT/d' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.1): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN (OF1.1): total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY (OF1.1):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.5)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow15 -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0609000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (65533) as in_port.
AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=none tun_id=0x11 metadata=0x22 packet=0001020304050010203040501234 actions=controller"])
AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=controller tun_id=0x11 metadata=0x33 packet=0001020304050010203040505678 actions=controller"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.5): total_len=14 tun_id=0x11,metadata=0x22,in_port=ANY (via packet_out) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN (OF1.5): total_len=14 tun_id=0x11,metadata=0x33,in_port=CONTROLLER (via packet_out) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY (OF1.5):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that metadata and userdata are encoded in NXT_PACKET_IN2.
AT_SETUP([ofproto - packet-out with metadata and userdata (NXT_PACKET_IN2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P nxt_packet_in2 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a load action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl packet-out br0 "in_port=controller packet=0001020304050010203040501234 actions=load(0xfafafafa5a5a5a5a->OXM_OF_METADATA[[0..63]]),load(0xaa->NXM_NX_PKT_MARK[[]]),controller(userdata=01.02.03.04.05)"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
NXT_PACKET_IN2: total_len=14 pkt_mark=0xaa,metadata=0xfafafafa5a5a5a5a,in_port=CONTROLLER (via action) data_len=14 (unbuffered)
 userdata=01.02.03.04.05
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that 1.5 packet_out is properly encoded/decoded.
AT_SETUP([ofproto - packet-out with set_field metadata (OpenFlow 1.5)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0409000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a couple of set-field action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 CONTROLLER 'set_field:0xfafafafa5a5a5a5a->metadata, controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.3): total_len=14 metadata=0xfafafafa5a5a5a5a,in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that packet_type PT_ETH is properly encoded/decoded in 1.5 packet_out.
AT_SETUP([ofproto - packet-out with set_field metadata with packet_type PT_ETH (OpenFlow 1.5)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0409000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a couple of set-field action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=controller packet=0001020304050010203040501234 packet_type(0,0x0) actions=set_field:0xfafafafa5a5a5a5a->metadata,controller"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.3): total_len=14 metadata=0xfafafafa5a5a5a5a,in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that packet_type PT_IPV4 is properly encoded/decoded in 1.5 packet_out.
AT_SETUP([ofproto - packet-out with set_field metadata with packet_type PT_IPV4 on PTAP bridge (OpenFlow 1.5)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P standard -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0409000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a couple of set-field action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow15 packet-out br0 "in_port=controller packet=4500002012344000ff1155670a0000140a00001e006400c8000cea78ffffffff packet_type(1,0x800) actions=set_field:0xfafafafa5a5a5a5a->metadata,controller"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.3): total_len=32 packet_type=(1,0x800),metadata=0xfafafafa5a5a5a5a,in_port=CONTROLLER (via action) data_len=32 (unbuffered)
packet_type=(1,0x800),nw_src=10.0.0.20,nw_dst=10.0.0.30,nw_proto=17,nw_tos=0,nw_ecn=0,nw_ttl=255,tp_src=100,tp_dst=200 udp_csum:ea78
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that metadata is encoded in packet_in structures,
dnl supported by NXAST.
AT_SETUP([ofproto - packet-out with metadata (NXM)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P nxt_packet_in monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a load action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl packet-out br0 "in_port=controller packet=0001020304050010203040501234 actions=load(0xfafafafa5a5a5a5a->OXM_OF_METADATA[[0..63]]),load(0xaa->NXM_NX_PKT_MARK[[]]),controller"])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
NXT_PACKET_IN: total_len=14 pkt_mark=0xaa,metadata=0xfafafafa5a5a5a5a,in_port=CONTROLLER (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that metadata is encoded in packet_in structures,
dnl supported by NXAST.
AT_SETUP([ofproto - packet-out with metadata (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow12 -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a set-field action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 none 'set_field:0xfafafafa5a5a5a5a->metadata, controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 metadata=0xfafafafa5a5a5a5a,in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that metadata is encoded in packet_in structures,
dnl supported by NXAST.
AT_SETUP([ofproto - packet-out with metadata and dual set_field (OpenFlow 1.3)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow13 -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0409000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a couple of set-field action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 none 'set_field:0xfafafafa5a5a5a5a->metadata, set_field:0x6b->metadata, controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.3): total_len=14 metadata=0x6b,in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that tunnel metadata is encoded in packet_in structures.
AT_SETUP([ofproto - packet-out with tunnel metadata (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow12 -P standard monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with set field actions to set some tunnel metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 none 'set_field:127.0.0.1->tun_src,set_field:0x01020304->tun_id,set_field:192.168.0.1->tun_dst, controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 tun_id=0x1020304,tun_src=127.0.0.1,tun_dst=192.168.0.1,in_port=ANY (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

m4_divert_push([PREPARE_TESTS])
# Sorts groups of lines that start with a space, without moving them
# past the nearest line that does not start with a space.
[
multiline_sort () {
    $PYTHON -c '
import sys

buffer = []
while True:
    line = sys.stdin.readline()
    if not line:
        break
    if line.startswith(" "):
        buffer.append(line)
    else:
        sys.stdout.write("".join(sorted(buffer)))
        sys.stdout.write(line)
        buffer = []
sys.stdout.write("".join(sorted(buffer)))
'
}
]
m4_divert_pop([PREPARE_TESTS])

AT_SETUP([ofproto - flow monitoring])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:1

# Start a monitor watching the flow table and check the initial reply.
ovs-ofctl monitor br0 watch: --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
  [NXST_FLOW_MONITOR reply:
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:1
OFPT_BARRIER_REPLY:
])

# Add, delete, and modify some flows and check the updates.
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
ovs-ofctl add-flow br0 in_port=0,dl_vlan=124,actions=output:2
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:5
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,dl_vlan_pcp=0,actions=output:6
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,dl_vlan_pcp=1,actions=output:7
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:8
ovs-ofctl add-flow br0 in_port=0,dl_vlan=65535,dl_vlan_pcp=0,actions=output:9
ovs-ofctl add-flow br0 in_port=0,dl_vlan=65535,dl_vlan_pcp=1,actions=output:10
ovs-ofctl add-flow br0 in_port=0,dl_vlan=65535,actions=output:11
ovs-ofctl add-flow br0 in_port=0,dl_vlan=8191,dl_vlan_pcp=0,actions=output:12
ovs-ofctl add-flow br0 in_port=0,dl_vlan=8191,dl_vlan_pcp=1,actions=output:13
ovs-ofctl add-flow br0 in_port=0,dl_vlan=8191,actions=output:14
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=0,actions=output:15
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=1,actions=output:16
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,actions=output:17
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=0,actions=output:18
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=1,actions=output:19
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,actions=output:20
ovs-ofctl add-flow br0 in_port=0,dl_vlan_pcp=0,actions=output:21
ovs-ofctl add-flow br0 in_port=0,dl_vlan_pcp=1,actions=output:22
ovs-ofctl add-flow br0 in_port=0,actions=output:23
ovs-ofctl mod-flows br0 dl_vlan=123,actions=output:3
ovs-ofctl mod-flows br0 cookie=5,dl_vlan=123,actions=output:3
ovs-ofctl del-flows br0 dl_vlan=123
ovs-ofctl del-flows br0
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log | multiline_sort], [0],
[NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=124 actions=output:2
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:5
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:6
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:7
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:8
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:9
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:10
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,vlan_tci=0x0000 actions=output:11
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=0 actions=output:12
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=1 actions=output:13
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=4095 actions=output:14
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:15
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:16
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0 actions=output:17
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:18
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:19
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0 actions=output:20
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan_pcp=0 actions=output:21
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan_pcp=1 actions=output:22
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0 actions=output:23
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:3
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:3
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:3
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0x5 in_port=0,dl_vlan=123 actions=output:3
 event=MODIFIED table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:3
 event=MODIFIED table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:3
NXST_FLOW_MONITOR reply (xid=0x0):
 event=DELETED reason=delete table=0 cookie=0x5 in_port=0,dl_vlan=123 actions=output:3
 event=DELETED reason=delete table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:3
 event=DELETED reason=delete table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:3
NXST_FLOW_MONITOR reply (xid=0x0):
 event=DELETED reason=delete table=0 cookie=0 in_port=0 actions=output:23
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=0 actions=output:20
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:18
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:19
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=124 actions=output:2
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=4095 actions=output:14
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=0 actions=output:12
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=1 actions=output:13
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan_pcp=0 actions=output:21
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan_pcp=1 actions=output:22
 event=DELETED reason=delete table=0 cookie=0 in_port=0,vlan_tci=0x0000 actions=output:11
OFPT_BARRIER_REPLY:
])

# Check that our own changes are reported as full updates.
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
ovs-ofctl add-flow br0 in_port=1,actions=output:2
ovs-ofctl add-flow br0 in_port=2,actions=output:1
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send 010e004812345678003fffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000ffffffffffff0000
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log | multiline_sort], [0],
[NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=1 actions=output:2
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=2 actions=output:1
OFPT_BARRIER_REPLY:
send: OFPT_FLOW_MOD: DEL priority=0 actions=drop
NXST_FLOW_MONITOR reply (xid=0x0):
 event=DELETED reason=delete table=0 cookie=0 in_port=1 actions=output:2
 event=DELETED reason=delete table=0 cookie=0 in_port=2 actions=output:1
OFPT_BARRIER_REPLY:
])

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow monitoring with !own])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:1

# Start a monitor watching the flow table and check the initial reply.
ovs-ofctl monitor br0 watch:\!own --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
  [NXST_FLOW_MONITOR reply:
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:1
OFPT_BARRIER_REPLY:
])

# Check that our own changes are reported as abbreviations.
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
ovs-ofctl add-flow br0 in_port=1,actions=output:2
ovs-ofctl add-flow br0 in_port=2,actions=output:1
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send 010e004812345678003fffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000ffffffffffff0000
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
[NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=1 actions=output:2
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=2 actions=output:1
OFPT_BARRIER_REPLY:
send: OFPT_FLOW_MOD: DEL priority=0 actions=drop
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ABBREV xid=0x12345678
OFPT_BARRIER_REPLY:
])

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow monitoring with out_port])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

ovs-ofctl add-flow br0 in_port=0,dl_vlan=121,actions=output:1
ovs-ofctl add-flow br0 in_port=0,dl_vlan=122,actions=output:1
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:2

# Start a monitor watching the flow table and check the initial reply.
ovs-ofctl monitor br0 watch:out_port=2 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
  [NXST_FLOW_MONITOR reply:
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:2
OFPT_BARRIER_REPLY:
])

ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log

# Add, modify flows and check the updates.
ovs-ofctl mod-flows br0 dl_vlan=121,actions=drop
ovs-ofctl mod-flows br0 dl_vlan=122,actions=output:1,output:2
ovs-appctl -t ovs-ofctl ofctl/barrier

ovs-ofctl mod-flows br0 dl_vlan=123,actions=output:1,output:2
ovs-appctl -t ovs-ofctl ofctl/barrier

ovs-ofctl mod-flows br0 dl_vlan=122,actions=output:1
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-ofctl mod-flows br0 dl_vlan=123,actions=output:2
ovs-appctl -t ovs-ofctl ofctl/barrier

AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
[NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=122 actions=output:1,output:2
OFPT_BARRIER_REPLY:
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:1,output:2
OFPT_BARRIER_REPLY:
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=122 actions=output:1
OFPT_BARRIER_REPLY:
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:2
OFPT_BARRIER_REPLY:
])

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow monitoring pause and resume])
AT_KEYWORDS([monitor])

# The maximum socket receive buffer size is important for this test, which
# tests behavior when the receive buffer overflows.
if test -e /proc/sys/net/core/rmem_max; then
    # Linux
    rmem_max=`cat /proc/sys/net/core/rmem_max`
elif rmem_max=`sysctl -n net.inet.tcp.recvbuf_max 2>/dev/null`; then
    : # FreeBSD, NetBSD
else
    # Don't know how to get maximum socket receive buffer on this OS
    AT_SKIP_IF([:])
fi
# Calculate the total amount of queuing: rmem_max in the kernel, 128 kB
# in ofproto sending userspace (see ofmonitor_flush() in connmgr.c).
queue_size=`expr $rmem_max + 128 \* 1024`
echo rmem_max=$rmem_max queue_size=$queue_size

# If there's too much queuing skip the test to avoid timing out.
AT_SKIP_IF([test $rmem_max -gt 1048576])

# Each flow update message takes up at least 48 bytes of space in queues
# and in practice more than that.
n_msgs=`expr $queue_size / 48`
echo n_msgs=$n_msgs

OVS_VSWITCHD_START

# Start a monitor watching the flow table, then make it block.
on_exit 'kill `cat ovs-ofctl.pid`'
ovs-ofctl monitor br0 watch: --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/block

# Add $n_msgs flows.
(echo "in_port=2,actions=output:2"
$PYTHON -c '
for i in range('$n_msgs'):
    print("cookie=1,reg1=%d,actions=drop" % i)
') > flows.txt
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
# Check that multipart flow dumps work properly:
AT_CHECK([ovs-ofctl diff-flows br0 flows.txt])
AT_CHECK([ovs-ofctl add-flow br0 in_port=1,cookie=3,actions=drop])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=2,cookie=2,actions=output:2])
AT_CHECK([ovs-ofctl del-flows br0 cookie=1/-1])

ovs-appctl -t ovs-ofctl ofctl/unblock

# Wait for the connection resumed.
# A barrier doesn't work for this purpose.
#    https://www.mail-archive.com/dev@openvswitch.org/msg27013.html
#    https://www.mail-archive.com/dev@openvswitch.org/msg27675.html
OVS_WAIT_UNTIL([grep NXT_FLOW_MONITOR_RESUMED monitor.log])

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

# Check that the flow monitor reported the same number of flows
# added and deleted, but fewer than we actually added and deleted.
adds=`grep -c 'ADDED.*reg1=' monitor.log`
deletes=`grep -c 'DELETED.*reg1=' monitor.log`
echo adds=$adds deletes=$deletes
AT_CHECK([test $adds -gt 100 && test $adds -lt $n_msgs])
AT_CHECK([test $adds = $deletes])

# Check that the flow monitor reported everything in the expected order:
#
#     event=ADDED table=0 cookie=0x1 reg1=0x22
# ...
#    NXT_FLOW_MONITOR_PAUSED:
# ...
#     event=DELETED reason=delete table=0 cookie=0x1 reg1=0x22
# ...
#     event=ADDED table=0 cookie=0x3 in_port=1
#     event=MODIFIED table=0 cookie=0x2 in_port=2 actions=output:2
#    NXT_FLOW_MONITOR_RESUMED:
#
# except that, between the PAUSED and RESUMED, the order of the ADDED
# and MODIFIED lines lines depends on hash order, that is, it varies
# as we change the hash function or change architecture.  Therefore,
# we use a couple of tests below to accept both orders.
AT_CHECK([ofctl_strip < monitor.log | sed -n -e '
/reg1=0x22$/p
/cookie=0x[[23]]/p
/NXT_FLOW_MONITOR_PAUSED:/p
/NXT_FLOW_MONITOR_RESUMED:/p
' > monitor.log.subset])
AT_CHECK([grep -v MODIFIED monitor.log.subset], [0], [dnl
 event=ADDED table=0 cookie=0x1 reg1=0x22
NXT_FLOW_MONITOR_PAUSED:
 event=DELETED reason=delete table=0 cookie=0x1 reg1=0x22
 event=ADDED table=0 cookie=0x3 in_port=1
NXT_FLOW_MONITOR_RESUMED:
])
AT_CHECK([grep -v ADDED monitor.log.subset], [0], [dnl
NXT_FLOW_MONITOR_PAUSED:
 event=DELETED reason=delete table=0 cookie=0x1 reg1=0x22
 event=MODIFIED table=0 cookie=0x2 in_port=2 actions=output:2
NXT_FLOW_MONITOR_RESUMED:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - event filtering (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send an OpenFlow13 message (04), OFPT_GET_ASYNC_REQUEST (1a), length (8), xid (0a)
ovs-appctl -t ovs-ofctl ofctl/send 041a00080000000a
ovs-appctl -t ovs-ofctl ofctl/barrier

# Check default setting
read -r -d '' expected <<'EOF'
EOF

AT_CHECK([ofctl_strip < monitor.log], [], [dnl
send: OFPT_GET_ASYNC_REQUEST (OF1.3):
OFPT_GET_ASYNC_REPLY (OF1.3):
 master:
       PACKET_IN: no_match action
     PORT_STATUS: add delete modify
    FLOW_REMOVED: idle hard delete group_delete
     ROLE_STATUS: (off)
    TABLE_STATUS: (off)
  REQUESTFORWARD: (off)

 slave:
       PACKET_IN: (off)
     PORT_STATUS: add delete modify
    FLOW_REMOVED: (off)
     ROLE_STATUS: (off)
    TABLE_STATUS: (off)
  REQUESTFORWARD: (off)
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - ofport_request])
OVS_VSWITCHD_START
add_of_ports br0 1 2 3

set_and_check_specific_ofports () {
    ovs-vsctl set Interface p1 ofport_request="$1" -- \
	      set Interface p2 ofport_request="$2" -- \
	      set Interface p3 ofport_request="$3"
    ofports=`ovs-vsctl get Interface p1 ofport -- \
		       get Interface p2 ofport -- \
		       get Interface p3 ofport`
    AT_CHECK_UNQUOTED([echo $ofports], [0], [$1 $2 $3
])
}
for pre in      '1 2 3' '1 3 2' '2 1 3' '2 3 1' '3 1 2' '3 2 1'; do
    for post in '1 2 3' '1 3 2' '2 1 3' '2 3 1' '3 1 2' '3 2 1'; do
        echo -----------------------------------------------------------
        echo "Check changing port numbers from $pre to $post"
	set_and_check_specific_ofports $pre
	set_and_check_specific_ofports $post
    done
done

ovs-vsctl del-port p3

set_and_check_poorly_specified_ofports () {
    ovs-vsctl set Interface p1 ofport_request="$1" -- \
	      set Interface p2 ofport_request="$2"
    p1=`ovs-vsctl get Interface p1 ofport`
    p2=`ovs-vsctl get Interface p2 ofport`
    echo $p1 $p2

    AT_CHECK([test "$p1" != "$p2"])
    if test "$1" = "$2" && test "$1" != '[[]]'; then
        # One port number must be the requested one.
	AT_CHECK([test "$p1" = "$1" || test "$p2" = "$1"])
	# The other port number must be different (already tested above).
    else
        AT_CHECK([test "$1" = '[[]]' || test "$p1" = "$1"])
        AT_CHECK([test "$2" = '[[]]' || test "$p2" = "$2"])
    fi
}
for pre in      '1 2' '[[]] 2' '1 [[]]' '[[]] [[]]' '2 1' '[[]] 1' '2 [[]]' \
                '1 1' '2 2'; do
    for post in '1 2' '[[]] 2' '1 [[]]' '[[]] [[]]' '2 1' '[[]] 1' '2 [[]]' \
                '1 1' '2 2'; do
        echo -----------------------------------------------------------
        echo "Check changing port numbers from $pre to $post"
        set_and_check_poorly_specified_ofports $pre
        set_and_check_poorly_specified_ofports $post
    done
done
OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - bundle open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send an OpenFlow14 message (05), OFPT_BUNDLE_CONTROL (21), length (10), xid (0a)
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle double open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send twice an OpenFlow14 message (05), OFPT_BUNDLE_CONTROL (21), length (10), xid (0a)
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle close without open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle double close (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BUNDLE_CLOSED
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle close, different flags (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BAD_FLAGS
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle commit without open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Commit
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 04 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle commit, different flags (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Commit
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 04 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BAD_FLAGS
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle discard without open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Discard
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 06 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=DISCARD_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=DISCARD_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - bundle with multiple flow mods (OpenFlow 1.4)])
OVS_VSWITCHD_START

AT_CHECK([ovs-appctl vlog/set vconn:dbg])

AT_CHECK([ovs-ofctl --no-names del-flows br0])

AT_DATA([flows.txt], [dnl
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=1
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=2
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=3
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=4
delete
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=5
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=6
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=7
delete in_port=2 dl_src=00:88:99:aa:bb:cc
])

AT_CHECK([ovs-ofctl --no-names --bundle add-flows br0 flows.txt])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:5
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:6
NXST_FLOW reply:
])

AT_DATA([flows.txt], [dnl
modify actions=drop
modify_strict in_port=2 dl_src=00:77:88:99:aa:bb actions=7
])

AT_CHECK([ovs-ofctl --no-names --bundle add-flows br0 flows.txt])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:7
NXST_FLOW reply:
])

# Adding an existing flow acts as a modify, and delete_strict also works.
AT_DATA([flows.txt], [dnl
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=8
delete_strict in_port=2 dl_src=00:66:77:88:99:aa
add in_port=2 dl_src=00:66:77:88:99:aa actions=drop
])

AT_CHECK([ovs-ofctl --no-names --bundle add-flows br0 flows.txt])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:8
 in_port=2,dl_src=00:66:77:88:99:aa actions=drop
NXST_FLOW reply:
])

dnl Check logs for OpenFlow trace
# Prevent race.
OVS_WAIT_UNTIL([vconn_sub < ovs-vswitchd.log | test `grep -- "|vconn|DBG|unix: sent (Success): NXST_FLOW reply" | wc -l` -ge 3])
AT_CHECK([print_vconn_debug | vconn_sub | ofctl_strip], [0], [dnl
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: OFPT_FLOW_MOD: DEL actions=drop
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO (OF1.4):
 version bitmap: 0x05
vconn|DBG|unix: negotiated OpenFlow version 0x05 (we support version 0x07 and earlier, peer supports version 0x05)
vconn|DBG|unix: received: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=OPEN_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=OPEN_REPLY flags=0
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=output:1
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:77:88:99:aa:bb idle:60 actions=output:2
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:88:99:aa:bb:cc idle:70 actions=output:3
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=output:4
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): DEL table:255 actions=drop
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=output:5
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:77:88:99:aa:bb idle:60 actions=output:6
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:88:99:aa:bb:cc idle:70 actions=output:7
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): DEL table:255 in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST (OF1.4):
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY (OF1.4):
vconn|DBG|unix: received: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REPLY flags=0
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: received: NXST_FLOW request:
vconn|DBG|unix: sent (Success): NXST_FLOW reply:
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:5
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:6
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO (OF1.4):
 version bitmap: 0x05
vconn|DBG|unix: negotiated OpenFlow version 0x05 (we support version 0x07 and earlier, peer supports version 0x05)
vconn|DBG|unix: received: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=OPEN_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=OPEN_REPLY flags=0
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): MOD actions=drop
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): MOD_STRICT in_port=2,dl_src=00:77:88:99:aa:bb actions=output:7
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST (OF1.4):
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY (OF1.4):
vconn|DBG|unix: received: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REPLY flags=0
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: received: NXST_FLOW request:
vconn|DBG|unix: sent (Success): NXST_FLOW reply:
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:7
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO (OF1.4):
 version bitmap: 0x05
vconn|DBG|unix: negotiated OpenFlow version 0x05 (we support version 0x07 and earlier, peer supports version 0x05)
vconn|DBG|unix: received: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=OPEN_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=OPEN_REPLY flags=0
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:77:88:99:aa:bb idle:60 actions=output:8
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): DEL_STRICT table:255 in_port=2,dl_src=00:66:77:88:99:aa actions=drop
vconn|DBG|unix: received: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD in_port=2,dl_src=00:66:77:88:99:aa actions=drop
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST (OF1.4):
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY (OF1.4):
vconn|DBG|unix: received: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0 type=COMMIT_REPLY flags=0
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: received: NXST_FLOW request: 
vconn|DBG|unix: sent (Success): NXST_FLOW reply:
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:8
 in_port=2,dl_src=00:66:77:88:99:aa actions=drop
])

AT_CHECK([grep " flow_mods in the last " ovs-vswitchd.log | sed -e 's/^.*connmgr|INFO|//' | vconn_sub], [0], [dnl
br0<->unix: 1 flow_mods in the last 0 s (1 deletes)
br0<->unix: 9 flow_mods in the last 0 s (7 adds, 2 deletes)
br0<->unix: 2 flow_mods in the last 0 s (2 modifications)
br0<->unix: 3 flow_mods in the last 0 s (2 adds, 1 deletes)
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - failing bundle commit (OpenFlow 1.4)])
OVS_VSWITCHD_START

AT_CHECK([ovs-ofctl del-flows br0])

ovs-ofctl add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=11
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=22
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=33
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:11
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:22
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=output:33
NXST_FLOW reply:
])

# last line uses illegal table number (OVS internal table)
AT_DATA([flows.txt], [dnl
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=1
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=2
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=3
modify idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=4
delete
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=5
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=6
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=7
delete in_port=2 dl_src=00:88:99:aa:bb:cc
add table=254 actions=drop
])

AT_CHECK([ovs-ofctl --bundle add-flows br0 flows.txt 2>&1 | sed '/talking to/,$d' | strip_xids],
[0], [dnl
Error OFPBRC_EPERM for: OFPT_FLOW_MOD (OF1.4): ADD table:254 actions=drop
])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:11
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:22
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=output:33
NXST_FLOW reply:
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - bundle timeout (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

ovs-appctl time/stop

# Send an OpenFlow14 message (05), OFPT_BUNDLE_CONTROL (21), length (10), xid (01)
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 01 00 00 00 01 00 00 00 03"
ovs-appctl time/warp 8000
# Send a bundle flow mod, it should keep the bundle alive.
ovs-appctl -t ovs-ofctl ofctl/send "05 22 00 a0 00 00 00 02 00 00 00 01 00 00 00 03 \
05 0e 00 90 00 00 00 02 00 00 00 00 00 00 00 00 \
00 00 00 00 00 00 00 00 01 00 00 00 00 00 ff ff \
ff ff ff ff ff ff ff ff ff ff ff ff 00 00 00 00 \
00 01 00 42 80 00 00 04 00 00 00 01 80 00 08 06 \
50 54 00 00 00 06 80 00 06 06 50 54 00 00 00 05 \
80 00 0a 02 08 06 80 00 0c 02 00 00 80 00 2a 02 \
00 02 80 00 2c 04 c0 a8 00 02 80 00 2e 04 c0 a8 \
00 01 00 00 00 00 00 00 00 04 00 18 00 00 00 00 \
00 00 00 10 00 00 00 03 00 00 00 00 00 00 00 00 \
"
ovs-appctl time/warp 8000
# Send a bundle close, it should keep the bundle alive.
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 03 00 00 00 01 00 02 00 03"
ovs-appctl time/warp 11000
# Make sure that timeouts are processed after the expiry
ovs-appctl time/warp 1000
# Send a Commit, but too late.
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 04 00 00 00 01 00 04 00 03"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
send: OFPT_BUNDLE_ADD_MESSAGE (OF1.4):
 bundle_id=0x1 flags=atomic ordered
OFPT_FLOW_MOD (OF1.4): ADD table:1 priority=65535,arp,in_port=1,vlan_tci=0x0000/0x1fff,dl_src=50:54:00:00:00:06,dl_dst=50:54:00:00:00:05,arp_spa=192.168.0.2,arp_tpa=192.168.0.1,arp_op=2 actions=output:3
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic ordered
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REPLY flags=0
OFPT_ERROR (OF1.4): OFPBFC_TIMEOUT
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic ordered
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - bundle open (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send an OpenFlow13 message (04), OFPT_EXPERIMENTER (04), length (0018),
# xid (0000000a), ONF_EXPERIMENTER_ID (4F4E4600),
# ONFT_BUNDLE_CONTROL (2300 = 0x08FC), bundle id (00000001),
# message type (0000), and flags (0002)
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle double open (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send twice an OpenFlow13 message (04), OFPT_EXPERIMENTER (04), length (0018),
# xid (0000000a), ONF_EXPERIMENTER_ID (4F4E4600),
# ONFT_BUNDLE_CONTROL (2300 = 0x08FC), bundle id (00000001),
# message type (0000), and flags (0002)
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.3):
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_ERROR (OF1.3): OFPBFC_BAD_ID
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle close without open (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_ERROR (OF1.3): OFPBFC_BAD_ID
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle double close (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.3):
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.3):
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_ERROR (OF1.3): OFPBFC_BUNDLE_CLOSED
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle close, different flags (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 02 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.3):
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_ERROR (OF1.3): OFPBFC_BAD_FLAGS
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle commit without open (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Commit
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 04 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=COMMIT_REQUEST flags=ordered
OFPT_ERROR (OF1.3): OFPBFC_BAD_ID
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=COMMIT_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle commit, different flags (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Commit
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 00 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 04 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REQUEST flags=ordered
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.3):
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic
OFPT_ERROR (OF1.3): OFPBFC_BAD_FLAGS
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle discard without open (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Discard
ovs-appctl -t ovs-ofctl ofctl/send "04 04 00 18 00 00 00 0a 4F 4E 46 00 00 00 08 FC 00 00 00 01 00 06 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=DISCARD_REQUEST flags=ordered
OFPT_ERROR (OF1.3): OFPBFC_BAD_ID
ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0x1 type=DISCARD_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - bundle with multiple flow mods (OpenFlow 1.3)])
OVS_VSWITCHD_START

AT_CHECK([ovs-appctl vlog/set vconn:dbg])

AT_CHECK([ovs-ofctl --no-names del-flows br0])

AT_DATA([flows.txt], [dnl
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=1
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=2
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=3
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=4
delete
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=5
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=6
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=7
delete in_port=2 dl_src=00:88:99:aa:bb:cc
])

AT_CHECK([ovs-ofctl -O OpenFlow13 --no-names --bundle add-flows br0 flows.txt])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:5
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:6
NXST_FLOW reply:
])

AT_DATA([flows.txt], [dnl
modify actions=drop
modify_strict in_port=2 dl_src=00:77:88:99:aa:bb actions=7
])

AT_CHECK([ovs-ofctl -O OpenFlow13 --no-names --bundle add-flows br0 flows.txt])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:7
NXST_FLOW reply:
])

# Adding an existing flow acts as a modify, and delete_strict also works.
AT_DATA([flows.txt], [dnl
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=8
delete_strict in_port=2 dl_src=00:66:77:88:99:aa
add in_port=2 dl_src=00:66:77:88:99:aa actions=drop
])

AT_CHECK([ovs-ofctl -O OpenFlow13 --bundle --no-names add-flows br0 flows.txt])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:8
 in_port=2,dl_src=00:66:77:88:99:aa actions=drop
NXST_FLOW reply:
])

dnl Check logs for OpenFlow trace
# Prevent race.
OVS_WAIT_UNTIL([vconn_sub < ovs-vswitchd.log | test `grep -- "|vconn|DBG|unix: sent (Success): NXST_FLOW reply" | wc -l` -ge 3])
AT_CHECK([print_vconn_debug | vconn_sub | ofctl_strip], [0], [dnl
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: OFPT_FLOW_MOD: DEL actions=drop
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO (OF1.3):
 version bitmap: 0x04
vconn|DBG|unix: negotiated OpenFlow version 0x04 (we support version 0x07 and earlier, peer supports version 0x04)
vconn|DBG|unix: received: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=OPEN_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=OPEN_REPLY flags=0
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=output:1
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:77:88:99:aa:bb idle:60 actions=output:2
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:88:99:aa:bb:cc idle:70 actions=output:3
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=output:4
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): DEL table:255 actions=drop
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=output:5
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:77:88:99:aa:bb idle:60 actions=output:6
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:88:99:aa:bb:cc idle:70 actions=output:7
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): DEL table:255 in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST (OF1.3):
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY (OF1.3):
vconn|DBG|unix: received: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REPLY flags=0
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: received: NXST_FLOW request:
vconn|DBG|unix: sent (Success): NXST_FLOW reply:
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:5
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:6
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO (OF1.3):
 version bitmap: 0x04
vconn|DBG|unix: negotiated OpenFlow version 0x04 (we support version 0x07 and earlier, peer supports version 0x04)
vconn|DBG|unix: received: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=OPEN_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=OPEN_REPLY flags=0
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): MOD actions=drop
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): MOD_STRICT in_port=2,dl_src=00:77:88:99:aa:bb actions=output:7
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST (OF1.3):
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY (OF1.3):
vconn|DBG|unix: received: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REPLY flags=0
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: received: NXST_FLOW request:
vconn|DBG|unix: sent (Success): NXST_FLOW reply:
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:7
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO (OF1.3):
 version bitmap: 0x04
vconn|DBG|unix: negotiated OpenFlow version 0x04 (we support version 0x07 and earlier, peer supports version 0x04)
vconn|DBG|unix: received: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=OPEN_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=OPEN_REPLY flags=0
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:77:88:99:aa:bb idle:60 actions=output:8
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): DEL_STRICT table:255 in_port=2,dl_src=00:66:77:88:99:aa actions=drop
vconn|DBG|unix: received: ONFT_BUNDLE_ADD_MESSAGE (OF1.3):
 bundle_id=0 flags=atomic ordered
OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:66:77:88:99:aa actions=drop
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST (OF1.3):
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY (OF1.3):
vconn|DBG|unix: received: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
vconn|DBG|unix: sent (Success): ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REPLY flags=0
vconn|DBG|unix: sent (Success): OFPT_HELLO (OF1.6):
 version bitmap: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
vconn|DBG|unix: received: OFPT_HELLO:
 version bitmap: 0x01
vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x07 and earlier, peer supports version 0x01)
vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
vconn|DBG|unix: received: NXST_FLOW request: 
vconn|DBG|unix: sent (Success): NXST_FLOW reply:
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:8
 in_port=2,dl_src=00:66:77:88:99:aa actions=drop
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - failing bundle add message (OpenFlow 1.3)])
OVS_VSWITCHD_START

AT_CHECK([ovs-ofctl del-flows br0])

ovs-ofctl add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=11
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=22
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=33
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:11
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:22
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=output:33
NXST_FLOW reply:
])

# last line uses illegal table number (OVS internal table)
AT_DATA([flows.txt], [dnl
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=1
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=2
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=3
modify idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=4
delete
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=5
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=6
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=7
delete in_port=2 dl_src=00:88:99:aa:bb:cc
add table=254 actions=drop
])

AT_CHECK([ovs-ofctl -O OpenFlow13 --bundle add-flows br0 flows.txt 2>&1 | sed '/talking to/,$d' | strip_xids],
[0], [dnl
Error OFPBRC_EPERM for: OFPT_FLOW_MOD (OF1.3): ADD table:254 actions=drop
])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=output:11
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:22
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=output:33
NXST_FLOW reply:
])

OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - failing bundle commit (OpenFlow 1.3)])
OVS_VSWITCHD_START

AT_CHECK([ovs-ofctl del-flows br0])

# Invalid group numbers are detected at commit time
AT_DATA([flows.txt], [dnl
add idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=group:1
add idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=group:2
add idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=group:3
])

AT_CHECK([ovs-ofctl -O OpenFlow13 --bundle add-flows br0 flows.txt 2>&1 | sed '/talking to/,$d' | strip_xids],
[0], [dnl
Error OFPBAC_BAD_OUT_GROUP for: OFPT_FLOW_MOD (OF1.3): ADD in_port=2,dl_src=00:66:77:88:99:aa idle:50 actions=group:1
Error OFPBFC_MSG_FAILED for: ONFT_BUNDLE_CONTROL (OF1.3):
 bundle_id=0 type=COMMIT_REQUEST flags=atomic ordered
])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - monitor flows with tun_md])
OVS_VSWITCHD_START

AT_CHECK([ovs-ofctl add-tlv-map br0 "{class=0xffff,type=0,len=4}->tun_metadata0"])
AT_CHECK([ovs-ofctl add-flow br0 tun_metadata0=0x1,actions=drop])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [dnl
NXST_FLOW reply:
 tun_metadata0=0x1 actions=drop
])

AT_CAPTURE_FILE([ofctl_monitor.log])
dnl Usually ovs-ofctl monitor outputs on stderr, but the first message here
dnl is put on stdout, because it is handled by ofctl in dump_transaction()
dnl and not in monitor_vconn().
AT_CHECK([ovs-ofctl monitor br0 65534 watch: --detach --no-chdir --pidfile >ofctl_monitor.log 2>&1])

OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])

AT_CHECK([cat ofctl_monitor.log | ofctl_strip], [0], [dnl
NXST_FLOW_MONITOR reply:
 event=ADDED table=0 cookie=0 tun_metadata0=0x1
])

AT_CHECK([ovs-ofctl del-flows br0])

OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 4])

AT_CHECK([cat ofctl_monitor.log | ofctl_strip], [0], [dnl
NXST_FLOW_MONITOR reply:
 event=ADDED table=0 cookie=0 tun_metadata0=0x1
NXST_FLOW_MONITOR reply:
 event=DELETED reason=delete table=0 cookie=0 tun_metadata0=0x1
])

OVS_APP_EXIT_AND_WAIT([ovs-ofctl])

dnl Check that vswitchd hasn't crashed
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [dnl
NXST_FLOW reply:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow mod with tunnel metadata])
AT_KEYWORDS([ofp-actions])
OVS_VSWITCHD_START

AT_CHECK([ovs-ofctl add-tlv-map br0 "{class=0xffff,type=0,len=4}->tun_metadata0"])
AT_CHECK([ovs-ofctl add-flow br0 "in_port=1 actions=move:tun_metadata0[[0..31]]->NXM_NX_REG0[[]]"])

dnl Check the length of tun_metadata0 in the replied OXM header.
dnl Ignore the first 0x50 bytes of hex dump from the reply msg since the NXM
dnl header that describes the tunnel metadata starts at offset 0x50.
AT_CHECK([ovs-ofctl dump-flows br0 -mmmm], [0], [stdout])
AT_CHECK([sed -e 's/duration=[[0-9.]]*s/duration=?s/' -e 's/idle_age=[[0-9]]*/idle_age=?/' -e '/^000000[[0-4]]0 / d' stdout | strip_xids], [0], [dnl
NXST_FLOW reply:
 cookie=0x0, duration=?s, table=0, n_packets=0, n_bytes=0, idle_age=?, in_port=1 actions=move:NXM_NX_TUN_METADATA0[[0..31]]->NXM_NX_REG0[[]]
00000050  ff ff 00 18 00 00 23 20-00 06 00 20 00 00 00 00 |......# ... ....|
00000060  00 01 50 04 00 01 00 04-                        |..P.....        |
])

dnl Check actions that may use tun_metadata
AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=move:tun_metadata1[[0..31]]->NXM_NX_REG0[[]]"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=move:tun_metadata0[[32..63]]->NXM_NX_REG0[[]]"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=push:tun_metadata1[[0..31]]"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=pop:tun_metadata0[[32..63]]"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=3, actions=load:0x11223344->tun_metadata1"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=output:tun_metadata1[[0..31]]"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=output:tun_metadata0[[32..63]]"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=multipath(eth_src,50,modulo_n,1,0,tun_metadata1[[0..31]])"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=multipath(eth_src,50,modulo_n,1,0,tun_metadata0[[32..63]])"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=bundle_load(eth_src,50,hrw,ofport,tun_metadata1[[0..31]], slaves:4,8)"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=bundle_load(eth_src,50,hrw,ofport,tun_metadata0[[32..63]], slaves:4,8)"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=learn(tun_metadata1[[0..31]]=reg0[[0..31]])"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=learn(tun_metadata0[[32..63]]=reg0[[0..31]])"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=clone(move:tun_metadata1[[0..31]]->reg0[[0..31]])"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "in_port=2 actions=clone(move:tun_metadata0[[32..63]]->reg0[[0..31]])"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "ip actions=ct(commit,zone=tun_metadata1[[0..15]],exec(set_field:0x01->ct_mark))"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "ip actions=ct(commit,zone=tun_metadata0[[32..47]],exec(set_field:0x01->ct_mark))"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

AT_CHECK([ovs-ofctl add-flow br0 "ip actions=ct(commit,zone=1,exec(move:tun_metadata1[[0..31]]->ct_mark))"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl add-flow br0 "ip actions=ct(commit,zone=1,exec(move:tun_metadata0[[32..63]]->ct_mark))"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: OFPBAC_BAD_SET_LEN
])

dnl Check match field with tun_metadata
AT_CHECK([ovs-ofctl add-flow br0 "tun_metadata0=0x11223344 actions=output:2"], [0], [], [stderr])
AT_CHECK([ovs-ofctl add-flow br0 "tun_metadata1=0x11223344 actions=output:2"], [1], [], [stderr])
AT_CHECK([strip_xids < stderr | sed '/FLOW_MOD/,$d'], [0], [dnl
OFPT_ERROR: NXFMFC_INVALID_TLV_FIELD
])

AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [dnl)
NXST_FLOW reply:
 in_port=1 actions=move:NXM_NX_TUN_METADATA0[[0..31]]->NXM_NX_REG0[[]]
 tun_metadata0=0x11223344 actions=output:2
])

OVS_VSWITCHD_STOP(["/NXFMFC_INVALID_TLV_FIELD/d
/tun_metadata0/d
/OFPBAC_BAD_SET_LEN/d"])
AT_CLEANUP

AT_SETUP([ofproto - flush flows, groups, and meters for controller change])
AT_KEYWORDS([flow flows group group meter])
OVS_VSWITCHD_START

add_flow_group_and_meter () {
    AT_CHECK([ovs-ofctl add-flow br0 in_port=1,actions=2])
    AT_CHECK([ovs-ofctl -O OpenFlow11 add-group br0 group_id=1234,type=all,bucket=output:10
    AT_CHECK([ovs-ofctl -O OpenFlow13 add-meter br0 'meter=1 pktps burst stats bands=type=drop rate=1 burst_size=1'])
])
}

verify_added () {
    AT_CHECK([ovs-ofctl --no-stats dump-flows br0], [0], [dnl
 in_port=1 actions=output:2
])
    AT_CHECK([ovs-ofctl -O OpenFlow11 dump-groups br0], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1) (xid=0x2):
 group_id=1234,type=all,bucket=actions=output:10
])
    AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br0], [0], [dnl
OFPST_METER_CONFIG reply (OF1.3) (xid=0x2):
meter=1 pktps burst stats bands=
type=drop rate=1 burst_size=1
])
}

verify_deleted () {
    AT_CHECK([ovs-ofctl --no-stats dump-flows br0])
    AT_CHECK([ovs-ofctl -O OpenFlow11 dump-groups br0], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1) (xid=0x2):
])
    AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br0], [0], [dnl
OFPST_METER_CONFIG reply (OF1.3) (xid=0x2):
])
}

# Add flow, group, meter and check that they're there, without a controller.
add_flow_group_and_meter
verify_added

# Set up a controller and verify that the flow and group were deleted,
# then add them back.
AT_CHECK([ovs-vsctl set-controller br0 'tcp:<invalid>:6653'])
verify_deleted
add_flow_group_and_meter
verify_added

# Change the controller and verify that the flow and group are still there.
AT_CHECK([ovs-vsctl set-controller br0 'tcp:<invalid2>:6653'])
verify_added

# Clear the controller and verify that the flow and group were deleted.
AT_CHECK([ovs-vsctl del-controller br0])
verify_deleted

OVS_VSWITCHD_STOP(["/<invalid/d"])
AT_CLEANUP
