AT_BANNER([ofproto])

AT_SETUP([ofproto - echo request])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn probe br0])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - handling messages with bad version])
OVS_VSWITCHD_START

# Start a monitor running OpenFlow 1.0, then send the switch an OF1.1 features
# request
AT_CHECK([ovs-ofctl -P openflow10 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/send 0205000801234567
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//
/ECHO/d' monitor.log], [0], [dnl
send: OFPT_FEATURES_REQUEST (OF1.1):
OFPT_ERROR (OF1.1): OFPBRC_BAD_VERSION
OFPT_FEATURES_REQUEST (OF1.1):
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP(["/received OpenFlow version 0x02 != expected 01/d"])
AT_CLEANUP

AT_SETUP([ofproto - feature request, config request])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPT_FEATURES_REPLY: dpid:fedcba9876543210
n_tables:254, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: OUTPUT SET_VLAN_VID SET_VLAN_PCP STRIP_VLAN SET_DL_SRC SET_DL_DST SET_NW_SRC SET_NW_DST SET_NW_TOS SET_TP_SRC SET_TP_DST ENQUEUE
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY: frags=normal miss_send_len=0
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - set OpenFlow port number])
OVS_VSWITCHD_START(
       [add-port br0 p1 -- set Interface p1 type=dummy --\
        add-port br0 p2 -- set Interface p2 type=dummy ofport_request=99])
AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
AT_CHECK([[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/00:0.$/00:0x/' < stdout]],
      [0], [dnl
OFPT_FEATURES_REPLY: dpid:fedcba9876543210
n_tables:254, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: OUTPUT SET_VLAN_VID SET_VLAN_PCP STRIP_VLAN SET_DL_SRC SET_DL_DST SET_NW_SRC SET_NW_DST SET_NW_TOS SET_TP_SRC SET_TP_DST ENQUEUE
 1(p1): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 99(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br0): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY: frags=normal miss_send_len=0
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port stats - (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_PORT reply: 1 ports
  port LOCAL: rx pkts=0, bytes=0, drop=0, errs=0, frame=0, over=0, crc=0
           tx pkts=0, bytes=0, drop=0, errs=0, coll=0
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port stats - (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_PORT reply (OF1.2): 1 ports
  port LOCAL: rx pkts=0, bytes=0, drop=0, errs=0, frame=0, over=0, crc=0
           tx pkts=0, bytes=0, drop=0, errs=0, coll=0
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port stats - (OpenFlow 1.4)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout | sed 's/duration=[[0-9.]]*s/duration=?s/'],
  [0], [dnl
OFPST_PORT reply (OF1.4): 1 ports
  port LOCAL: rx pkts=0, bytes=0, drop=0, errs=0, frame=0, over=0, crc=0
           tx pkts=0, bytes=0, drop=0, errs=0, coll=0
           duration=?s
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port-desc stats (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_PORT_DESC reply:
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port-desc stats (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_PORT_DESC reply (OF1.2):
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - port-desc stats (OpenFlow 1.5)])
OVS_VSWITCHD_START
ADD_OF_PORTS([br0], 1, 2, 3)
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout | sed 's/00:0./00:0x/'], [0], [dnl
OFPST_PORT_DESC reply (OF1.5):
 1(p1): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 2(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 3(p3): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br0): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-ports-desc br0 2], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout | sed 's/00:0./00:0x/'], [0], [dnl
OFPST_PORT_DESC reply (OF1.5):
 2(p2): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - queue stats - (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn queue-stats br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_QUEUE reply: 0 queues
])
AT_CHECK([ovs-ofctl -vwarn queue-stats br0 ANY 5], [0],
  [OFPT_ERROR (xid=0x2): OFPQOFC_BAD_QUEUE
OFPST_QUEUE request (xid=0x2):port=ANY queue=5
])
AT_CHECK([ovs-ofctl -vwarn queue-stats br0 10], [0],
  [OFPT_ERROR (xid=0x2): OFPQOFC_BAD_PORT
OFPST_QUEUE request (xid=0x2):port=10 queue=ALL
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - queue stats - (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn queue-stats br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_QUEUE reply (OF1.2): 0 queues
])
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn queue-stats br0 ALL 5], [0],
  [OFPT_ERROR (OF1.2) (xid=0x2): OFPQOFC_BAD_QUEUE
OFPST_QUEUE request (OF1.2) (xid=0x2):port=ANY queue=5
])
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn queue-stats br0 10], [0],
  [OFPT_ERROR (OF1.2) (xid=0x2): OFPQOFC_BAD_PORT
OFPST_QUEUE request (OF1.2) (xid=0x2):port=10 queue=ALL
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - queue stats - (OpenFlow 1.4)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn queue-stats br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_QUEUE reply (OF1.4): 0 queues
])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn queue-stats br0 ALL 5], [0],
  [OFPT_ERROR (OF1.4) (xid=0x2): OFPQOFC_BAD_QUEUE
OFPST_QUEUE request (OF1.4) (xid=0x2):port=ANY queue=5
])
AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn queue-stats br0 10], [0],
  [OFPT_ERROR (OF1.4) (xid=0x2): OFPQOFC_BAD_PORT
OFPST_QUEUE request (OF1.4) (xid=0x2):port=10 queue=ALL
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - queue configuration - (OpenFlow 1.0)])
OVS_VSWITCHD_START
ADD_OF_PORTS([br0], [1], [2])
AT_CHECK([ovs-ofctl queue-get-config br0 1], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY: port=1
])
AT_CHECK([ovs-ofctl queue-get-config br0 10], [0],
  [OFPT_ERROR (xid=0x2): OFPQOFC_BAD_PORT
OFPT_QUEUE_GET_CONFIG_REQUEST (xid=0x2): port=10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - queue configuration - (OpenFlow 1.2)])
OVS_VSWITCHD_START
ADD_OF_PORTS([br0], [1], [2])
AT_CHECK([ovs-ofctl -O OpenFlow12 queue-get-config br0 1], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPT_QUEUE_GET_CONFIG_REPLY (OF1.2): port=1
])
AT_CHECK([ovs-ofctl -O OpenFlow12 queue-get-config br0 10], [0],
  [OFPT_ERROR (OF1.2) (xid=0x2): OFPQOFC_BAD_PORT
OFPT_QUEUE_GET_CONFIG_REQUEST (OF1.2) (xid=0x2): port=10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - del group])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -F OXM-OpenFlow15 -O OpenFlow15 -vwarn dump-groups br0 1234], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.5):
 group_id=1234,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1235,type=all,bucket=actions=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0], [0])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - del group deletes flows])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-groups br0 groups.txt])
AT_DATA([flows.txt], [dnl
tcp actions=group:1234
udp actions=group:1235
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 tcp actions=group:1234
 udp actions=group:1235
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 udp actions=group:1235
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0 group_id=1234])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
 udp actions=group:1235
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn del-groups br0])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-flows br0 | ofctl_strip | sort],
[0], [dnl
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - flow mod checks group availability])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 group_id=1234,type=all,bucket=output:10])
AT_DATA([flows.txt], [dnl
tcp actions=group:1234
udp actions=group:1235
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flow br0 'tcp actions=group:1234'])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flow br0 'tcp actions=group:1235'], [1], [], [stderr])

# The output should look like this:
#
# 00000000  02 0e 00 98 00 00 00 02-00 00 00 00 00 00 00 00 |................|
# 00000010  00 00 00 00 00 00 00 00-ff 00 00 00 00 00 80 00 |................|
# 00000020  ff ff ff ff ff ff ff ff-ff ff ff ff 00 00 00 00 |................|
# 00000030  00 00 00 58 00 00 00 00-00 00 03 d7 00 00 00 00 |...X............|
#
# This 'sed' command captures the error message but drops details.
AT_CHECK([sed '/truncated/d
/^000000.0/d' stderr | STRIP_XIDS], [0],
  [OFPT_ERROR (OF1.1): OFPBAC_BAD_OUT_GROUP
OFPT_FLOW_MOD (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group description])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 group_id=1234,type=all,bucket=output:10], [0], [stdout])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1234,type=all,bucket=actions=output:10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group description])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-group br0 group_id=1234,type=all,bucket=output:10])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-groups br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_DESC reply (OF1.1):
 group_id=1234,type=all,bucket=actions=output:10
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group features])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn dump-group-features br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_GROUP_FEATURES reply (OF1.2):
 Group table:
    Types:  0xf
    Capabilities:  0x7
    All group :
        max_groups = 0xffffff00 actions=0x03ff9801
    Select group :
        max_groups = 0xffffff00 actions=0x00000000
    Indirect group :
        max_groups = 0xffffff00 actions=0x00000000
    Fast Failover group :
        max_groups = 0xffffff00 actions=0x00000000
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - group stats])
OVS_VSWITCHD_START
AT_DATA([groups.txt], [dnl
group_id=1234,type=all,bucket=output:10
group_id=1235,type=all,bucket=output:10
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-groups br0 groups.txt])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn add-flow br0 'tcp actions=group:1234'])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-group-stats br0 group_id=1234], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout | sort], [0], [dnl
 group_id=1234,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 -vwarn dump-group-stats br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout | sort], [0], [dnl
 group_id=1234,ref_count=1,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
 group_id=1235,ref_count=0,packet_count=0,byte_count=0,bucket0:packet_count=0,byte_count=0
OFPST_GROUP reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.0)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 0' \
    'noflood NO_FLOOD 0' \
    'down PORT_DOWN,NO_FLOOD LINK_DOWN' \
    'flood PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV 0' \
    'receive 0 0'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([STRIP_XIDS stdout], [0], [dnl
OFPT_FEATURES_REPLY: dpid:fedcba9876543210
n_tables:254, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: OUTPUT SET_VLAN_VID SET_VLAN_PCP STRIP_VLAN SET_DL_SRC SET_DL_DST SET_NW_SRC SET_NW_DST SET_NW_TOS SET_TP_SRC SET_TP_DST ENQUEUE
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY: frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.2)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 0' \
    'down PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV 0' \
    'receive 0 0'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -O OpenFlow12 -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([STRIP_XIDS stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.2): dpid:fedcba9876543210
n_tables:254, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.2): frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port (OpenFlow 1.4)])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 0' \
    'down PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV 0' \
    'receive 0 0'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -O OpenFlow14 -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([STRIP_XIDS stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.4): dpid:fedcba9876543210
n_tables:254, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS
OFPST_PORT_DESC reply (OF1.4):
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.4): frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl add-flows br0 -])
AT_CHECK([ovs-ofctl add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -F nxm add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl dump-aggregate br0 table=0 | STRIP_XIDS], [0], [dnl
NXST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply:
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl -F openflow10 add-flows br0 -])
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
OFPST_FLOW reply:
])
AT_CHECK([ovs-ofctl -F openflow10 dump-aggregate br0 table=0 | STRIP_XIDS], [0], [dnl
OFPST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl -F openflow10 del-flows br0])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.1):
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl -O OpenFlow11 add-flows br0 -])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-aggregate br0 table=0 | STRIP_XIDS], [0], [dnl
OFPST_AGGREGATE reply (OF1.1): packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.1):
 table=1, in_port=4 actions=output:3
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow_mod negative test (OpenFlow 1.1)])
OVS_VSWITCHD_START(
  [set bridge br0 protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13])
AT_CHECK([ovs-ofctl add-flow -O OpenFlow11 br0 table=1,action=goto_table:2])

# The error message here actually comes from ovs-ofctl, not from ovs-vswitchd,
# but at least it's the same code in ofpacts_check() that issues the error.
AT_CHECK([ovs-ofctl add-flow -O OpenFlow11 br0 table=1,action=goto_table:1],
  [1], [],
  [ovs-ofctl: actions are invalid with specified match (OFPBIC_BAD_TABLE_ID)
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - set-field flow_mod commands (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 ipv6,table=1,in_port=3,actions=drop])
AT_CHECK([ovs-ofctl add-flow br0 ipv6,table=1,in_port=3,actions=set_field:fe80:0123:4567:890a:a6ba:dbff:fefe:59fa-\>ipv6_src])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 table=1, ipv6,in_port=3 actions=load:0xa6badbfffefe59fa->NXM_NX_IPV6_SRC[[0..63]],load:0xfe8001234567890a->NXM_NX_IPV6_SRC[[64..127]]
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.2):
])
AT_CHECK([echo 'in_port=2,actions=1' | ovs-ofctl -O OpenFlow12 add-flows br0 -])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=1,actions=2])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 table=1,in_port=4,actions=3])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:2
 in_port=2 actions=output:1
 table=1, in_port=4 actions=output:3
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip], [0], [OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - dump flows with cookie])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl dump-aggregate br0 table=0 | STRIP_XIDS], [0], [dnl
NXST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=3
])
AT_CHECK([ovs-ofctl dump-flows br0 cookie=0x3/-1 | ofctl_strip | sort], [0], [dnl
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl dump-aggregate br0 cookie=0x3/-1 | STRIP_XIDS], [0], [dnl
NXST_AGGREGATE reply: packet_count=0 byte_count=0 flow_count=1
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie change (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F openflow10 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F openflow10 mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F openflow10 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=1 actions=output:1
OFPST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie change (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F nxm add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=1 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - no mod flow with cookie change (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl The OpenFlow 1.2 spec states that the cookie may not be modified
AT_SETUP([ofproto - no mod flow with cookie change (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.2):
])

AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 cookie=0x2,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flows based on cookie mask (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=0x1/0xff,actions=4])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:4
 cookie=0x1, in_port=2 actions=output:4
 cookie=0x2, in_port=3 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flows based on cookie mask (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.1):
])

AT_CHECK([ovs-ofctl -O OpenFlow11 mod-flows br0 cookie=0x1/0xff,actions=4])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:4
 cookie=0x1, in_port=2 actions=output:4
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flows based on cookie mask (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.2):
])

AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 cookie=0x1/0xff,actions=4])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:4
 cookie=0x1, in_port=2 actions=output:4
 cookie=0x2, in_port=3 actions=output:1
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl The OpenFlow 1.2 spec states that the cookie may not be modified
AT_SETUP([ofproto - mod flows based on cookie mask with cookie change])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x1, in_port=2 actions=output:1
 cookie=0x2, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=1/-1,cookie=4,actions=4])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=3 actions=output:1
 cookie=0x4, in_port=1 actions=output:4
 cookie=0x4, in_port=2 actions=output:4
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask==0) - NXM])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F nxm mod-flows br0 in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask==0) - OF1.1])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow11 mod-flows br0 in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=output:1
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask==0) - OF1.2])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow12 mod-flows br0 in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask!=0) - NXM])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -F nxm mod-flows br0 cookie=1/1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -F nxm dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask!=0) - OF1.1])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow11 mod-flows br0 cookie=1/1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.1):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod flow with cookie miss (mask!=0) - OF1.2])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O openflow12 mod-flows br0 cookie=1/1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O openflow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows with cookies])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on cookie])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl del-flows br0 cookie=0x3/-1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on cookie mask])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, in_port=2 actions=output:1
 cookie=0x3, in_port=3 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0 cookie=0x3/0x1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, in_port=2 actions=output:1
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on table id (NXM)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0 table=0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, table=1, in_port=2 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0 table=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
NXST_FLOW reply:
])
AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on table id (OpenFlow 1.1)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 table=0])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0 table=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.1):
])
AT_CHECK([ovs-ofctl -O OpenFlow11 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow11 dump-flows br0 | ofctl_strip], [0], [dnl
OFPST_FLOW reply (OF1.1):
 cookie=0x2, table=1, in_port=2 actions=output:1
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows based on table id (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0 table=0])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0 table=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x1,in_port=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 cookie=0x2,in_port=2,table=1,actions=1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=output:1
 cookie=0x2, table=1, in_port=2 actions=output:1
OFPST_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl -O OpenFlow12 del-flows br0])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow table configuration (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Check the default configuration.
(echo "OFPST_TABLE reply (xid=0x2): 254 tables
  0: classifier: wild=0x3fffff, max=1000000, active=0
               lookup=0, matched=0"
 x=1
 while test $x -lt 254; do
   printf "  %d: %-8s: wild=0x3fffff, max=1000000, active=0
               lookup=0, matched=0
" $x table$x
   x=`expr $x + 1`
 done) > expout
AT_CHECK([ovs-ofctl dump-tables br0], [0], [expout])
# Change the configuration.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=main \
     -- --id=@t1 create Flow_Table flow-limit=1024 \
     -- set bridge br0 'flow_tables={1=@t1,0=@t0}' \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
<1>
])
# Check that the configuration was updated.
mv expout orig-expout
(echo "OFPST_TABLE reply (xid=0x2): 254 tables
  0: main    : wild=0x3fffff, max=1000000, active=0
               lookup=0, matched=0
  1: table1  : wild=0x3fffff, max=  1024, active=0
               lookup=0, matched=0"
 tail -n +6 orig-expout) > expout
AT_CHECK([ovs-ofctl dump-tables br0], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow table configuration (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Check the default configuration.
(mid="wild=0xfffffffff, max=1000000,"
 tail="
               lookup=0, matched=0
               match=0xfffffffff, instructions=0x00000007, config=0x00000003
               write_actions=0x00000000, apply_actions=0x00000000
               write_setfields=0x0000000fffffffff
               apply_setfields=0x0000000fffffffff
               metadata_match=0xffffffffffffffff
               metadata_write=0xffffffffffffffff"
 echo "OFPST_TABLE reply (OF1.2) (xid=0x2): 254 tables
  0: classifier: $mid active=0$tail"
 x=1
 while test $x -lt 254; do
   printf "  %d: %-8s: $mid active=0$tail
" $x table$x
   x=`expr $x + 1`
 done) > expout
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-tables br0], [0], [expout])
# Change the configuration.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=main \
     -- --id=@t1 create Flow_Table flow-limit=1024 \
     -- set bridge br0 'flow_tables={1=@t1,0=@t0}' \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
<1>
])
# Check that the configuration was updated.
mv expout orig-expout
(echo "OFPST_TABLE reply (OF1.2) (xid=0x2): 254 tables
  0: main    : wild=0xfffffffff, max=1000000, active=0"
 tail -n +3 orig-expout | head -7
 echo "  1: table1  : wild=0xfffffffff, max=  1024, active=0"
 tail -n +11 orig-expout) > expout
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-tables br0], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - hard limits on flow table size (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 1 2 3 4; do
    ovs-ofctl add-flow br0 in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=drop
 in_port=4 actions=drop
NXST_FLOW reply:
])
# Adding another flow will be refused.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
])
# Also a mod-flow that would add a flow will be refused.
AT_CHECK([ovs-ofctl mod-flows br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
])
# Replacing or modifying an existing flow is allowed.
AT_CHECK([ovs-ofctl add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=output:1
 in_port=4 actions=NORMAL
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - hard limits on flow table size (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 1 2 3 4; do
    ovs-ofctl -O OpenFlow12 add-flow br0 in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=drop
 in_port=4 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will be refused.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR (OF1.2): OFPFMFC_TABLE_FULL
])
# Replacing or modifying an existing flow is allowed.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=drop
 in_port=2 actions=drop
 in_port=3 actions=output:1
 in_port=4 actions=NORMAL
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 idle_timeout=${in_port}0,in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=1 actions=drop
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
NXST_FLOW reply:
])
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
 in_port=5 actions=drop
NXST_FLOW reply:
])
# A mod-flow that adds a flow also causes eviction, but replacing or
# modifying an existing flow doesn't.
AT_CHECK([ovs-ofctl mod-flows br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=3 actions=output:1
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
 in_port=6 actions=drop
NXST_FLOW reply:
])
# Flows with no timeouts at all cannot be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=7,actions=normal])
AT_CHECK([ovs-ofctl add-flow br0 in_port=8,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR: OFPFMFC_TABLE_FULL
])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
 in_port=6 actions=drop
 in_port=7 actions=NORMAL
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl -O OpenFlow12 add-flow br0 idle_timeout=${in_port}0,in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=1 actions=drop
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=drop
 idle_timeout=40, in_port=4 actions=drop
 in_port=5 actions=drop
OFPST_FLOW reply (OF1.2):
])
# In Open Flow 1.2 a mod-flow does not ever add a flow and thus
# has no effect on eviction
AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl -O OpenFlow12 mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=drop
 idle_timeout=30, in_port=3 actions=output:1
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Flows with no timeouts at all cannot be evicted.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=7,actions=normal])
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=8,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR (OF1.2): OFPFMFC_TABLE_FULL
])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=4 actions=NORMAL
 in_port=5 actions=drop
 in_port=6 actions=drop
 in_port=7 actions=NORMAL
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with fairness (OpenFlow 1.0)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=evict flow-limit=4 \
                                   overflow-policy=evict \
                                   groups='"NXM_OF_IN_PORT[[]]"' \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
ovs-ofctl add-flows br0 - <<EOF
idle_timeout=10 in_port=2 dl_src=00:44:55:66:77:88 actions=drop
idle_timeout=20 in_port=1 dl_src=00:11:22:33:44:55 actions=drop
idle_timeout=30 in_port=1 dl_src=00:22:33:44:55:66 actions=drop
idle_timeout=40 in_port=1 dl_src=00:33:44:55:66:77 actions=drop
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=20, in_port=1,dl_src=00:11:22:33:44:55 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
NXST_FLOW reply:
])
# Adding another flow will cause the one that expires soonest within
# the largest group (those with in_port=1) to be evicted.  In this
# case this is not the same as the one that expires soonest overall
# (which is what makes the test interesting):
AT_CHECK([ovs-ofctl add-flow br0 in_port=2,dl_src=00:55:66:77:88:99,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
# Enlarge the flow limit, change the eviction policy back to strictly
# based on expiration, and and add some flows.
AT_CHECK([ovs-vsctl set Flow_Table evict groups='[[]]' flow-limit=7])
ovs-ofctl add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=drop
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=drop
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=drop
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
# Adding another flow will cause the one that expires soonest overall
# to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 'idle_timeout=80 in_port=2 dl_src=00:99:aa:bb:cc:dd actions=drop'])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
# Reducing the flow limit also causes the flows that expire soonest
# overall to be evicted.
AT_CHECK([ovs-vsctl set Flow_Table evict flow-limit=4])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with fairness (OpenFlow 1.2)])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=evict flow-limit=4 \
                                   overflow-policy=evict \
                                   groups='"NXM_OF_IN_PORT[[]]"' \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
ovs-ofctl -O OpenFlow12 add-flows br0 - <<EOF
idle_timeout=10 in_port=2 dl_src=00:44:55:66:77:88 actions=drop
idle_timeout=20 in_port=1 dl_src=00:11:22:33:44:55 actions=drop
idle_timeout=30 in_port=1 dl_src=00:22:33:44:55:66 actions=drop
idle_timeout=40 in_port=1 dl_src=00:33:44:55:66:77 actions=drop
EOF
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=20, in_port=1,dl_src=00:11:22:33:44:55 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest within
# the largest group (those with in_port=1) to be evicted.  In this
# case this is not the same as the one that expires soonest overall
# (which is what makes the test interesting):
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 in_port=2,dl_src=00:55:66:77:88:99,actions=drop])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Enlarge the flow limit, change the eviction policy back to strictly
# based on expiration, and and add some flows.
AT_CHECK([ovs-vsctl set Flow_Table evict groups='[[]]' flow-limit=7])
ovs-ofctl -O OpenFlow12 add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=drop
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=drop
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=drop
EOF
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=drop
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest overall
# to be evicted.
AT_CHECK([ovs-ofctl -O OpenFlow12 add-flow br0 'idle_timeout=80 in_port=2 dl_src=00:99:aa:bb:cc:dd actions=drop'])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=drop
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=drop
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=drop
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
# Reducing the flow limit also causes the flows that expire soonest
# overall to be evicted.
AT_CHECK([ovs-vsctl set Flow_Table evict flow-limit=4])
AT_CHECK([ovs-ofctl -O OpenFlow12 dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=drop
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=drop
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=drop
 in_port=2,dl_src=00:55:66:77:88:99 actions=drop
OFPST_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with modified hard timeout])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
ovs-appctl time/stop
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 hard_timeout=$((10 + in_port * 3)),in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=13, in_port=1 actions=drop
 hard_timeout=16, in_port=2 actions=drop
 hard_timeout=19, in_port=3 actions=drop
 hard_timeout=22, in_port=4 actions=drop
NXST_FLOW reply:
])
# Sleep and modify the one that expires soonest
ovs-appctl time/warp 5000
AT_CHECK([ovs-ofctl mod-flows br0 in_port=1,actions=drop])
# At this point the table would looks like:
#  in_port   seconds to expire
#     1            13
#     2            11
#     3            14
#     4            17
ovs-appctl time/warp 2000
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 hard_timeout=13, in_port=1 actions=drop
 hard_timeout=19, in_port=3 actions=drop
 hard_timeout=22, in_port=4 actions=drop
 in_port=5 actions=drop
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with modified idle timeout])
OVS_VSWITCHD_START([add-port br0 p1 -- set interface p1 type=dummy ofport_request=1])
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | ${PERL} $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 idle_timeout=$((10 + in_port * 3)),in_port=$in_port,actions=drop
done
ovs-appctl time/stop
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=13, in_port=1 actions=drop
 idle_timeout=16, in_port=2 actions=drop
 idle_timeout=19, in_port=3 actions=drop
 idle_timeout=22, in_port=4 actions=drop
NXST_FLOW reply:
])
# Sleep and receive on the flow that expires soonest
ovs-appctl time/warp 5000
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1)'])
# At this point the table would looks like:
#  in_port   seconds to expire
#     1            13
#     2            11
#     3            14
#     4            17
ovs-appctl time/warp 2000
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=19, in_port=3 actions=drop
 idle_timeout=22, in_port=4 actions=drop
 in_port=5 actions=drop
 n_packets=1, n_bytes=60, idle_timeout=13, in_port=1 actions=drop
NXST_FLOW reply:
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.0)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -P openflow10 monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    ovs-ofctl -v packet-out br0 controller controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -v packet-out br0 controller 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via no_match) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl packet-out br0 controller dec_ttl '002583dfb4000026b98cb0f908004500003fb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN: total_len=76 in_port=CONTROLLER (via invalid_ttl) data_len=76 (unbuffered)
udp,metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy ofport_request=1
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS: ADD: 1(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS: DEL: 1(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED:  reason=delete"
    fi
    AT_FAIL_IF([test X"$1" != X])

    ovs-appctl -t ovs-ofctl ofctl/barrier
    echo >>expout "OFPT_BARRIER_REPLY:"

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Set miss_send_len to 128 and enable invalid_ttl.
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700040080
check_async 3 OFPR_ACTION OFPR_INVALID_TTL OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Become slave, which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 0104001400000002000023200000000a00000002
check_async 4 OFPPR_ADD OFPPR_DELETE

# Use NXT_SET_ASYNC_CONFIG to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 01040028000000020000232000000013000000020000000500000005000000020000000200000005
check_async 5 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 01040018000000030000232000000014000000000000007b
check_async 6 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 010400180000000300002320000000140000000000000000

# Become master.
ovs-appctl -t ovs-ofctl ofctl/send 0104001400000002000023200000000a00000001
check_async 7 OFPR_ACTION OFPPR_ADD

ovs-appctl -t ovs-ofctl exit
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow12 monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    ovs-ofctl -O OpenFlow12 -v packet-out br0 none controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -O OpenFlow12 -v packet-out br0 none 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY (via no_match) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl -O OpenFlow12 packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003fb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=76 in_port=ANY (via invalid_ttl) data_len=76 (unbuffered)
udp,metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.2): ADD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.2): DEL: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl -O OpenFlow12 add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl -O OpenFlow12 --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.2):  reason=delete table_id=0"
    fi
    AT_FAIL_IF([test X"$1" != X])

    ovs-appctl -t ovs-ofctl ofctl/barrier
    echo >>expout "OFPT_BARRIER_REPLY (OF1.2):"

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Set miss_send_len to 128 and enable invalid_ttl.
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700040080
check_async 3 OFPR_ACTION OFPR_INVALID_TTL OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Become slave (OF 1.2), which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 031800180000000200000003000000000000000000000001
check_async 4 OFPPR_ADD OFPPR_DELETE

# Use NXT_SET_ASYNC_CONFIG to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 03040028000000020000232000000013000000020000000500000005000000020000000200000005
check_async 5 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 03040018000000030000232000000014000000000000007b
check_async 6 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 030400180000000300002320000000140000000000000000

# Become master (OF 1.2).
ovs-appctl -t ovs-ofctl ofctl/send 031800180000000400000002000000000000000000000002
check_async 7 OFPR_ACTION OFPPR_ADD

ovs-appctl -t ovs-ofctl exit
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.3)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    ovs-ofctl -O OpenFlow13 -v packet-out br0 none controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.3): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
    ovs-ofctl -O OpenFlow13 -v packet-out br0 none 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
    if test X"$1" = X"OFPR_NO_MATCH"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.3): total_len=14 in_port=ANY (via no_match) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl -O OpenFlow13 packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003fb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.3): total_len=76 in_port=ANY (via invalid_ttl) data_len=76 (unbuffered)
udp,metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:26:b9:8c:b0:f9,dl_dst=00:25:83:df:b4:00,nw_src=172.17.55.13,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=0,tp_src=55155,tp_dst=53 udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.3): ADD: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.3): DEL: ${INDEX}(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl -O OpenFlow13 add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl -O OpenFlow13 --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.3):  reason=delete table_id=0"
    fi
    AT_FAIL_IF([test X"$1" != X])

    ovs-appctl -t ovs-ofctl ofctl/barrier
    echo >>expout "OFPT_BARRIER_REPLY (OF1.3):"

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0409000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Become slave (OF 1.3), which should disable everything except port status.
ovs-appctl -t ovs-ofctl ofctl/send 041800180000000200000003000000000000000000000001
check_async 3 OFPPR_ADD OFPPR_DELETE

# Use OF 1.3 OFPT_SET_ASYNC to enable a patchwork of asynchronous messages.
ovs-appctl -t ovs-ofctl ofctl/send 041c002000000002000000020000000500000005000000020000000200000005
check_async 4 OFPR_INVALID_TTL OFPPR_DELETE OFPRR_DELETE

# Set controller ID 123.
ovs-appctl -t ovs-ofctl ofctl/send 04040018000000030000232000000014000000000000007b
check_async 5 OFPR_NO_MATCH OFPPR_DELETE OFPRR_DELETE

# Restore controller ID 0.
ovs-appctl -t ovs-ofctl ofctl/send 040400180000000300002320000000140000000000000000

# Become master (OF 1.3).
ovs-appctl -t ovs-ofctl ofctl/send 041800180000000400000002000000000000000000000002
check_async 6 OFPR_ACTION OFPPR_ADD

ovs-appctl -t ovs-ofctl exit
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that the role request/response messaging works
dnl and that generation_id is handled properly.
AT_SETUP([ofproto - controller role (OpenFlow 1.2)])
OVS_VSWITCHD_START
ON_EXIT([kill `cat c1.pid c2.pid`])

# Start two ovs-ofctl controller processes.
AT_CAPTURE_FILE([monitor1.log])
AT_CAPTURE_FILE([expout1])
AT_CAPTURE_FILE([experr1])
AT_CAPTURE_FILE([monitor2.log])
AT_CAPTURE_FILE([expout2])
AT_CAPTURE_FILE([experr2])
for i in 1 2; do
     AT_CHECK([ovs-ofctl -O OpenFlow12 monitor br0 --detach --no-chdir --pidfile=`pwd`/c$i.pid --unixctl=`pwd`/c$i])
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    ovs-appctl -t `pwd`/c$i ofctl/set-output-file monitor$i.log
    : > expout$i
    : > experr$i

    # find out current role
    ovs-appctl -t `pwd`/c$i ofctl/send 031800180000000200000000000000000000000000000000
    echo >>experr$i "send: OFPT_ROLE_REQUEST (OF1.2): role=nochange"
    echo >>expout$i "OFPT_ROLE_REPLY (OF1.2): role=equal"
done

# controller 1: Become slave (generation_id is initially undefined, so
# 2^63+2 should not be stale)
ovs-appctl -t `pwd`/c1 ofctl/send 031800180000000300000003000000008000000000000002
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.2): role=slave generation_id=9223372036854775810"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.2): role=slave generation_id=9223372036854775810"

# controller 2: Become master.
ovs-appctl -t `pwd`/c2 ofctl/send 031800180000000300000002000000008000000000000003
echo >>experr2 "send: OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=9223372036854775811"
echo >>expout2 "OFPT_ROLE_REPLY (OF1.2): role=master generation_id=9223372036854775811"

# controller 1: Try to become the master using a stale generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 031800180000000400000002000000000000000000000003
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=3"
echo >>expout1 "OFPT_ERROR (OF1.2): OFPRRFC_STALE"
echo >>expout1 "OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=3"

# controller 1: Become master using a valid generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 031800180000000500000002000000000000000000000001
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.2): role=master generation_id=1"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.2): role=master generation_id=1"

for i in 1 2; do
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    echo >>expout$i "OFPT_BARRIER_REPLY (OF1.2):"
done

# Check output.
for i in 1 2; do
    cp expout$i expout
    AT_CHECK([grep -v '^send:' monitor$i.log | STRIP_XIDS], [0], [expout])
    cp experr$i expout
    AT_CHECK([grep '^send:' monitor$i.log | STRIP_XIDS], [0], [expout])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that the role request/response messaging works,
dnl that generation_id is handled properly, and that role status update
dnl messages are sent when a controller's role gets changed from master
dnl to slave.
AT_SETUP([ofproto - controller role (OpenFlow 1.4)])
OVS_VSWITCHD_START
ON_EXIT([kill `cat c1.pid c2.pid`])

# Start two ovs-ofctl controller processes.
AT_CAPTURE_FILE([monitor1.log])
AT_CAPTURE_FILE([expout1])
AT_CAPTURE_FILE([experr1])
AT_CAPTURE_FILE([monitor2.log])
AT_CAPTURE_FILE([expout2])
AT_CAPTURE_FILE([experr2])
for i in 1 2; do
     AT_CHECK([ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile=`pwd`/c$i.pid --unixctl=`pwd`/c$i])
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    ovs-appctl -t `pwd`/c$i ofctl/set-output-file monitor$i.log
    : > expout$i
    : > experr$i

    # find out current role
    ovs-appctl -t `pwd`/c$i ofctl/send 051800180000000200000000000000000000000000000000
    echo >>experr$i "send: OFPT_ROLE_REQUEST (OF1.4): role=nochange"
    echo >>expout$i "OFPT_ROLE_REPLY (OF1.4): role=equal"
done

# controller 1: Become slave (generation_id is initially undefined, so
# 2^63+2 should not be stale)
ovs-appctl -t `pwd`/c1 ofctl/send 051800180000000300000003000000008000000000000002
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.4): role=slave generation_id=9223372036854775810"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.4): role=slave generation_id=9223372036854775810"

# controller 2: Become master.
ovs-appctl -t `pwd`/c2 ofctl/send 051800180000000300000002000000008000000000000003
echo >>experr2 "send: OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=9223372036854775811"
echo >>expout2 "OFPT_ROLE_REPLY (OF1.4): role=master generation_id=9223372036854775811"

# controller 1: Try to become the master using a stale generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 051800180000000400000002000000000000000000000003
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=3"
echo >>expout1 "OFPT_ERROR (OF1.4): OFPRRFC_STALE"
echo >>expout1 "OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=3"

# controller 1: Become master using a valid generation ID
ovs-appctl -t `pwd`/c1 ofctl/send 051800180000000500000002000000000000000000000001
echo >>experr1 "send: OFPT_ROLE_REQUEST (OF1.4): role=master generation_id=1"
echo >>expout1 "OFPT_ROLE_REPLY (OF1.4): role=master generation_id=1"
echo >>expout2 "OFPT_ROLE_STATUS (OF1.4): role=slave generation_id=1 reason=master_request"

for i in 1 2; do
    ovs-appctl -t `pwd`/c$i ofctl/barrier
    echo >>expout$i "OFPT_BARRIER_REPLY (OF1.4):"
done

# Check output.
for i in 1 2; do
    cp expout$i expout
    AT_CHECK([grep -v '^send:' monitor$i.log | STRIP_XIDS], [0], [expout])
    cp experr$i expout
    AT_CHECK([grep '^send:' monitor$i.log | STRIP_XIDS], [0], [expout])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.0) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.0)])
OVS_VSWITCHD_START
ADD_OF_PORTS([br0], [1])

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P openflow10 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (65533) as in_port.
AT_CHECK([ovs-ofctl packet-out br0 none controller,1 '0001020304050010203040501234'])
AT_CHECK([ovs-ofctl packet-out br0 controller controller,1 '0001020304050010203040505678'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

ovs-ofctl dump-ports br0

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN: total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.2) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow12 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (65533) as in_port.
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 none controller '0001020304050010203040501234'])
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 4294967293 controller '0001020304050010203040505678'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.1) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.1)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow11 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0209000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (65533) as in_port.
AT_CHECK([ovs-ofctl -O OpenFlow11 packet-out br0 none controller '0001020304050010203040501234'])
AT_CHECK([ovs-ofctl -O OpenFlow11 packet-out br0 4294967293 controller '0001020304050010203040505678'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.1): total_len=14 in_port=ANY (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_PACKET_IN (OF1.1): total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x5678
OFPT_BARRIER_REPLY (OF1.1):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that metadata is encoded in packet_in structures,
dnl supported by NXAST.
AT_SETUP([ofproto - packet-out with metadata (NXM)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -P nxm monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0109000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a load action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl packet-out br0 controller 'load(0xfafafafa5a5a5a5a->OXM_OF_METADATA[[0..63]]), load(0xaa->NXM_NX_PKT_MARK[[]]), controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
NXT_PACKET_IN: total_len=14 in_port=CONTROLLER metadata=0xfafafafa5a5a5a5a pkt_mark=0xaa (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that metadata is encoded in packet_in structures,
dnl supported by NXAST.
AT_SETUP([ofproto - packet-out with metadata (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow12 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with a load action to set some metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 none 'load(0xfafafafa5a5a5a5a->OXM_OF_METADATA[[0..63]]), controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY metadata=0xfafafafa5a5a5a5a (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that tunnel metadata is encoded in packet_in structures.
AT_SETUP([ofproto - packet-out with tunnel metadata (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl -O OpenFlow12 monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send a packet-out with set field actions to set some tunnel metadata, and forward to controller
AT_CHECK([ovs-ofctl -O OpenFlow12 packet-out br0 none 'set_field:127.0.0.1->tun_src,set_field:0x01020304->tun_id,set_field:192.168.0.1->tun_dst, controller' '0001020304050010203040501234'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=ANY tun_id=0x1020304 tun_src=127.0.0.1 tun_dst=192.168.0.1 (via action) data_len=14 (unbuffered)
metadata=0,in_port=0,vlan_tci=0x0000,dl_src=00:10:20:30:40:50,dl_dst=00:01:02:03:04:05,dl_type=0x1234
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow monitoring])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:1

# Start a monitor watching the flow table and check the initial reply.
ovs-ofctl monitor br0 watch: --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
  [NXST_FLOW_MONITOR reply:
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:1
OFPT_BARRIER_REPLY:
])

# Add, delete, and modify some flows and check the updates.
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
ovs-ofctl add-flow br0 in_port=0,dl_vlan=124,actions=output:2
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:5
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,dl_vlan_pcp=0,actions=output:6
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,dl_vlan_pcp=1,actions=output:7
ovs-ofctl add-flow br0 in_port=0,dl_vlan=123,actions=output:8
ovs-ofctl add-flow br0 in_port=0,dl_vlan=65535,dl_vlan_pcp=0,actions=output:9
ovs-ofctl add-flow br0 in_port=0,dl_vlan=65535,dl_vlan_pcp=1,actions=output:10
ovs-ofctl add-flow br0 in_port=0,dl_vlan=65535,actions=output:11
ovs-ofctl add-flow br0 in_port=0,dl_vlan=8191,dl_vlan_pcp=0,actions=output:12
ovs-ofctl add-flow br0 in_port=0,dl_vlan=8191,dl_vlan_pcp=1,actions=output:13
ovs-ofctl add-flow br0 in_port=0,dl_vlan=8191,actions=output:14
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=0,actions=output:15
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=1,actions=output:16
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,actions=output:17
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=0,actions=output:18
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,dl_vlan_pcp=1,actions=output:19
ovs-ofctl add-flow br0 in_port=0,dl_vlan=0,actions=output:20
ovs-ofctl add-flow br0 in_port=0,dl_vlan_pcp=0,actions=output:21
ovs-ofctl add-flow br0 in_port=0,dl_vlan_pcp=1,actions=output:22
ovs-ofctl add-flow br0 in_port=0,actions=output:23
ovs-ofctl mod-flows br0 dl_vlan=123,actions=output:3
ovs-ofctl mod-flows br0 cookie=5,dl_vlan=123,actions=output:3
ovs-ofctl del-flows br0 dl_vlan=123
ovs-ofctl del-flows br0
ovs-appctl -t ovs-ofctl ofctl/barrier
sort='
    # Sorts groups of lines that start with a space, without moving them
    # past the nearest line that does not start with a space.
    use warnings;
    use strict;
    my @buffer = ();
    while (<STDIN>) {
        if (/^ /) {
            push(@buffer, $_);
        } else {
            print $_ foreach sort(@buffer);
            print $_;
            @buffer = ();
        }
    }
    print $_ foreach sort(@buffer);
'
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log | ${PERL} -e "$sort"], [0],
[NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=124 actions=output:2
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:5
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:6
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:7
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:8
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:9
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:10
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,vlan_tci=0x0000 actions=output:11
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=0 actions=output:12
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=1 actions=output:13
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=4095 actions=output:14
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:15
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:16
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0 actions=output:17
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:18
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:19
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan=0 actions=output:20
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan_pcp=0 actions=output:21
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0,dl_vlan_pcp=1 actions=output:22
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=0 actions=output:23
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123 actions=output:3
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:3
 event=MODIFIED table=0 cookie=0 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:3
NXST_FLOW_MONITOR reply (xid=0x0):
 event=MODIFIED table=0 cookie=0x5 in_port=0,dl_vlan=123 actions=output:3
 event=MODIFIED table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:3
 event=MODIFIED table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:3
NXST_FLOW_MONITOR reply (xid=0x0):
 event=DELETED reason=delete table=0 cookie=0x5 in_port=0,dl_vlan=123 actions=output:3
 event=DELETED reason=delete table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=0 actions=output:3
 event=DELETED reason=delete table=0 cookie=0x5 in_port=0,dl_vlan=123,dl_vlan_pcp=1 actions=output:3
NXST_FLOW_MONITOR reply (xid=0x0):
 event=DELETED reason=delete table=0 cookie=0 in_port=0 actions=output:23
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=0 actions=output:20
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=0 actions=output:18
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=0,dl_vlan_pcp=1 actions=output:19
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=124 actions=output:2
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=4095 actions=output:14
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=0 actions=output:12
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan=4095,dl_vlan_pcp=1 actions=output:13
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan_pcp=0 actions=output:21
 event=DELETED reason=delete table=0 cookie=0 in_port=0,dl_vlan_pcp=1 actions=output:22
 event=DELETED reason=delete table=0 cookie=0 in_port=0,vlan_tci=0x0000 actions=output:11
OFPT_BARRIER_REPLY:
])

# Check that our own changes are reported as abbreviations.
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
ovs-ofctl add-flow br0 in_port=1,actions=output:2
ovs-ofctl add-flow br0 in_port=2,actions=output:1
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send 010e004812345678003fffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000ffffffffffff0000
ovs-appctl -t ovs-ofctl ofctl/barrier
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [NXST_FLOW reply:
])
AT_CHECK([sed 's/ (xid=0x[[1-9a-fA-F]][[0-9a-fA-F]]*)//' monitor.log], [0],
[NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=1 actions=output:2
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ADDED table=0 cookie=0 in_port=2 actions=output:1
OFPT_BARRIER_REPLY:
send: OFPT_FLOW_MOD: DEL priority=0 actions=drop
NXST_FLOW_MONITOR reply (xid=0x0):
 event=ABBREV xid=0x12345678
OFPT_BARRIER_REPLY:
])

ovs-appctl -t ovs-ofctl exit
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow monitoring pause and resume])
AT_KEYWORDS([monitor])

# The maximum socket receive buffer size is important for this test, which
# tests behavior when the receive buffer overflows.
if test -e /proc/sys/net/core/rmem_max; then
    # Linux
    rmem_max=`cat /proc/sys/net/core/rmem_max`
elif rmem_max=`sysctl -n net.inet.tcp.recvbuf_max 2>/dev/null`; then
    : # FreeBSD, NetBSD
else
    # Don't know how to get maximum socket receive buffer on this OS
    AT_SKIP_IF([:])
fi
# Calculate the total amount of queuing: rmem_max in the kernel, 128 kB
# in ofproto sending userspace (see ofmonitor_flush() in connmgr.c).
queue_size=`expr $rmem_max + 128 \* 1024`
echo rmem_max=$rmem_max queue_size=$queue_size

# If there's too much queuing skip the test to avoid timing out.
AT_SKIP_IF([test $rmem_max -gt 1048576])

# Each flow update message takes up at least 48 bytes of space in queues
# and in practice more than that.
n_msgs=`expr $queue_size / 48`
echo n_msgs=$n_msgs

OVS_VSWITCHD_START

# Start a monitor watching the flow table, then make it block.
ON_EXIT([kill `cat ovs-ofctl.pid`])
ovs-ofctl monitor br0 watch: --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])
ovs-appctl -t ovs-ofctl ofctl/block

# Add $n_msgs flows.
(echo "in_port=2,actions=output:2"
${PERL} -e '
    for ($i = 0; $i < '$n_msgs'; $i++) {
        print "cookie=1,reg1=$i,actions=drop\n";
    }
') > flows.txt
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
# Check that multipart flow dumps work properly:
AT_CHECK([ovs-ofctl diff-flows br0 flows.txt])
AT_CHECK([ovs-ofctl add-flow br0 in_port=1,cookie=3,actions=drop])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=2,cookie=2,actions=output:2])
AT_CHECK([ovs-ofctl del-flows br0 cookie=1/-1])

ovs-appctl -t ovs-ofctl ofctl/unblock

# Wait for the connection resumed.
# A barrier doesn't work for this purpose.
#    https://www.mail-archive.com/dev@openvswitch.org/msg27013.html
#    https://www.mail-archive.com/dev@openvswitch.org/msg27675.html
OVS_WAIT_UNTIL([grep NXT_FLOW_MONITOR_RESUMED monitor.log])

ovs-appctl -t ovs-ofctl exit

# Check that the flow monitor reported the same number of flows
# added and deleted, but fewer than we actually added and deleted.
adds=`grep -c 'ADDED.*reg1=' monitor.log`
deletes=`grep -c 'DELETED.*reg1=' monitor.log`
echo adds=$adds deletes=$deletes
AT_CHECK([test $adds -gt 100 && test $adds -lt $n_msgs])
AT_CHECK([test $adds = $deletes])

# Check that the flow monitor reported everything in the expected order:
#
#     event=ADDED table=0 cookie=0x1 reg1=0x22
# ...
#    NXT_FLOW_MONITOR_PAUSED:
# ...
#     event=DELETED reason=delete table=0 cookie=0x1 reg1=0x22
# ...
#     event=ADDED table=0 cookie=0x3 in_port=1
#     event=MODIFIED table=0 cookie=0x2 in_port=2 actions=output:2
#    NXT_FLOW_MONITOR_RESUMED:
#
# except that, between the PAUSED and RESUMED, the order of the ADDED
# and MODIFIED lines lines depends on hash order, that is, it varies
# as we change the hash function or change architecture.  Therefore,
# we use a couple of tests below to accept both orders.
AT_CHECK([ofctl_strip < monitor.log | sed -n -e '
/reg1=0x22$/p
/cookie=0x[[23]]/p
/NXT_FLOW_MONITOR_PAUSED:/p
/NXT_FLOW_MONITOR_RESUMED:/p
' > monitor.log.subset])
AT_CHECK([grep -v MODIFIED monitor.log.subset], [0], [dnl
 event=ADDED table=0 cookie=0x1 reg1=0x22
NXT_FLOW_MONITOR_PAUSED:
 event=DELETED reason=delete table=0 cookie=0x1 reg1=0x22
 event=ADDED table=0 cookie=0x3 in_port=1
NXT_FLOW_MONITOR_RESUMED:
])
AT_CHECK([grep -v ADDED monitor.log.subset], [0], [dnl
NXT_FLOW_MONITOR_PAUSED:
 event=DELETED reason=delete table=0 cookie=0x1 reg1=0x22
 event=MODIFIED table=0 cookie=0x2 in_port=2 actions=output:2
NXT_FLOW_MONITOR_RESUMED:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - event filtering (OpenFlow 1.3)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow13 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send an OpenFlow13 message (04), OFPT_GET_ASYNC_REQUEST (1a), length (8), xid (0a)
ovs-appctl -t ovs-ofctl ofctl/send 041a00080000000a
ovs-appctl -t ovs-ofctl ofctl/barrier

# Check default setting
read -r -d '' expected <<'EOF'
EOF

AT_CHECK([ofctl_strip < monitor.log], [], [dnl
send: OFPT_GET_ASYNC_REQUEST (OF1.3):
OFPT_GET_ASYNC_REPLY (OF1.3):
 master:
       PACKET_IN: no_match action
     PORT_STATUS: add delete modify
    FLOW_REMOVED: idle hard delete

 slave:
       PACKET_IN: (off)
     PORT_STATUS: add delete modify
    FLOW_REMOVED: (off)
OFPT_BARRIER_REPLY (OF1.3):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - ofport_request])
OVS_VSWITCHD_START
ADD_OF_PORTS([br0], [1], [2], [3])

set_and_check_specific_ofports () {
    ovs-vsctl set Interface p1 ofport_request="$1" -- \
	      set Interface p2 ofport_request="$2" -- \
	      set Interface p3 ofport_request="$3"
    ofports=`ovs-vsctl get Interface p1 ofport -- \
		       get Interface p2 ofport -- \
		       get Interface p3 ofport`
    AT_CHECK_UNQUOTED([echo $ofports], [0], [$1 $2 $3
])
}
for pre in      '1 2 3' '1 3 2' '2 1 3' '2 3 1' '3 1 2' '3 2 1'; do
    for post in '1 2 3' '1 3 2' '2 1 3' '2 3 1' '3 1 2' '3 2 1'; do
        echo -----------------------------------------------------------
        echo "Check changing port numbers from $pre to $post"
	set_and_check_ofports $pre
	set_and_check_ofports $post
    done
done

ovs-vsctl del-port p3

set_and_check_poorly_specified_ofports () {
    ovs-vsctl set Interface p1 ofport_request="$1" -- \
	      set Interface p2 ofport_request="$2"
    p1=`ovs-vsctl get Interface p1 ofport`
    p2=`ovs-vsctl get Interface p2 ofport`
    echo $p1 $p2

    AT_CHECK([test "$p1" != "$p2"])
    if test "$1" = "$2" && test "$1" != '[[]]'; then
        # One port number must be the requested one.
	AT_CHECK([test "$p1" = "$1" || test "$p2" = "$1"])
	# The other port number must be different (already tested above).
    else
        AT_CHECK([test "$1" = '[[]]' || test "$p1" == "$1"])
        AT_CHECK([test "$2" = '[[]]' || test "$p2" == "$2"])
    fi
}
for pre in      '1 2' '[[]] 2' '1 [[]]' '[[]] [[]]' '2 1' '[[]] 1' '2 [[]]' \
                '1 1' '2 2'; do
    for post in '1 2' '[[]] 2' '1 [[]]' '[[]] [[]]' '2 1' '[[]] 1' '2 [[]]' \
                '1 1' '2 2'; do
        echo -----------------------------------------------------------
        echo "Check changing port numbers from $pre to $post"
        set_and_check_poorly_specified_ofports $pre
        set_and_check_poorly_specified_ofports $post
    done
done
OVS_VSWITCHD_STOP
AT_CLEANUP


AT_SETUP([ofproto - bundles, open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send an OpenFlow14 message (05), OFPT_BUNDLE_CONTROL (21), length (10), xid (0a)
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundles, double open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Send twice an OpenFlow14 message (05), OFPT_BUNDLE_CONTROL (21), length (10), xid (0a)
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle close without open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle double close (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BUNDLE_CLOSED
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle close, different flags (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 02 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_FLAGS
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=CLOSE_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle commit without open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 04 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle commit, different flags (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 00 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 04 00 02"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REQUEST flags=atomic
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=OPEN_REPLY flags=0
OFPT_BARRIER_REPLY (OF1.4):
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=ordered
OFPT_ERROR (OF1.4): OFPBFC_BAD_FLAGS
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=COMMIT_REQUEST flags=ordered
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - bundle discard without open (OpenFlow 1.4)])
AT_KEYWORDS([monitor])
OVS_VSWITCHD_START

# Start a monitor, use the required protocol version
ovs-ofctl -O OpenFlow14 monitor br0 --detach --no-chdir --pidfile >monitor.log 2>&1
AT_CAPTURE_FILE([monitor.log])

# Open, Close, Close
ovs-appctl -t ovs-ofctl ofctl/send "05 21 00 10 00 00 00 0a 00 00 00 01 00 06 00 01"
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([ofctl_strip < monitor.log], [0], [dnl
send: OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=DISCARD_REQUEST flags=atomic
OFPT_ERROR (OF1.4): OFPBFC_BAD_ID
OFPT_BUNDLE_CONTROL (OF1.4):
 bundle_id=0x1 type=DISCARD_REQUEST flags=atomic
OFPT_BARRIER_REPLY (OF1.4):
])

OVS_VSWITCHD_STOP
AT_CLEANUP
